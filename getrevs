#!/bin/sh

# $Id: getrevs 3447 2016-01-22 06:32:32Z liub16 $

# SUMMARY
# The script checks:
#   Check supported Chassis Type based on platform
#   Check POST FW rev
#   Check BMC FW rev
#   Check BMC SSP FW rev
#   Check BIOS rev
#   Check BMC MAC address, IP address and source
#   Check ISCSI stuff, fw, device ID, MAC address
#   Check both SP board revs, and compatibility with the Chassis type
#   Check if TCO watchdog works
#   Check CDES FW rev
#   check Fan fw
#   Check BBU rev, supported part number and status
#   check eSLIC type
#   check CMD version
#   check PMC version
#   Check supported Power supply part number
#   Check power supply MCU FW rev
#   Check supported RAM size
#   Check SSD model number and FW rev
#   check gps
#   Check supported CPU model
#   Compare FW rev on SPA and SPB and make sure they are the same
#   check Hilda FW rev

# ADDING NEW FAMILY/PLATFORM:
# I. notes on adding new family:
#     1. add the new family to array supported_families (add it as the first element of the array)
#     2. add the "family specific routines"
#     3. they will be called automatically
# II. notes on adding new platform:
#     1. add the new platform to array supported_platforms (add it as the first element of the array)
#     2. add the "platform specific routines"
#     3. they will be called automatically
#
# CHANGELOG:
# v3.6 5/12/2016 Jianjun.Zhang2@emc.com
#    - AR AR
# v3.5 10/26/2015 Jianxiu.Gao@emc.com
#    - AR AR779101: Update the FFID for DownburstX SLIC
# v3.4 10/23/2015 Wei.Guan@emc.com
#    - AR 774381: Change the way to get and compare WANTPS_ACBEL and WANTPS_FLEX with PS_MCU.
# v3.3 09/18/2015 Wei.Guan@emc.com
#    - AR 764500: Change the way to get the wanted CDES FW version for Oberon
# v3.2 09/01/2015 Jianxiu.Gao@emc.com
#    - AR 762208: Chnage the way to detect total memory for Beachcomber
# v3.1 08/12/2015 Jianxiu.Gao@emc.com
#    - AR 754619: fix bugs that getrevs reporting old M.2 998  FW as OK for SSD model of SH9M2S66D064GHM01
# v3.0 08/03/2015 Wei.Guan@emc.com
#    - AR 751674 :update codes about checks for 611 Optimus power supplies (or with 4K drives in the system slots)
#    - change "S8FM08.0" to "S8FM08.2" in report_ssd function
# v2.9 07/30/2015 Wei.Guan@emc.com
#    - AR 751674 :checks for 611 Optimus power supplies (or with 4K drives in the system slots)
# v2.8 07/08/2015 Jianxiu.Gao@emc.com
#    - AR 723465 :getrevs running on BC-N1000 fails when the MCU fw is actually up
# v2.7 07/03/2015 Jianxiu.Gao@emc.com
#    - AR 731933: getrevs support for mismatched slic configuration
# v2.6 05/25/2015 Jianxiu.Gao@emc.com
#    - Re-structure rungetrevs/getrevs to use manifest file to get latest FW REV information
# v2.5 05/25/2015 Jianxiu.Gao@emc.com
#    - AR 733334: update wanted FW version to OB FW set 11.03
# v2.4 05/20/2015 Jianxiu.Gao@emc.com
#    - AR 731587/731589/712250- Support the power supply FW revision check for Oberon
# v2.3 05/19/2015 Jianxiu.Gao@emc.com
#    - AR 731519- support Oberon configure 2 and 4 chassis type checks.
#    - Mark S8FM08.0 as latest FW for Oberon Smart Modular SSD, since 8.2 is not ready in platdev stream code yet
# v2.2 05/15/2015 Jianxiu.Gao@emc.com
#    - Fix bugs in reporting PMC SAS/M.2 FW.
# v2.1 05/04/2015 Tianqi.Hu@emc.com
#    - getrevs support Bearcat
# v2.0 04/13/2015 Tianqi.Hu@emc.com
#    - Update the new checked in Bearcat FW release 2.20 && Oberon FW release 9.04
# V1.9 03/20/2015 Tianqi.Hu@emc.com
#    - getrevs support Bearcat
# V1.8 03/15/2015 Tianqi.Hu@emc.com
#    - change the way to check the chassis type
# v1.7 02/27/2015 Tianqi.Hu@emc.com
#    - remove some codes for AR 705931
# v1.6 02/13/2015 Tianqi.Hu@emc.com
#    - update the wanted FW version according to Oberon 08.02 FW set
#    - add code changes for SSD check
# v1.5 02/06/2015 Tianqi.Hu@emc.com
#    - change the way to report SAS Firmware version
# v1.4 01/27/2015 Tianqi.Hu@emc.com
#    - check the rev of Hilda
#    - disable bbu & ssd check
#    - update iscsi check 
#    - change the way to compare BBU FW revision
# v1.3 01/26/2015 Jianxiu.Gao@emc.com
#    - update WANT FW version according to Oberon 08.01/Hyperion 08.02
#    - update memory configuration for MOONS
#    - remove disk FW checks
# v1.2 11/27/2014 bolt.liu@emc.com
#    - fix AR 689296
# v1.1 10/14/2014 bolt.liu@emc.com
#    - support hyperion
# v1.0 10/10/2014 bolt.liu@emc.com
#    - initial version


VERSION="v3.5"
SVN_DATE="$Date: 2016-01-22 01:32:32 -0500 (Fri, 22 Jan 2016) $"
DATE=`echo $SVN_DATE | awk '{print $2}'`

echo "getrevs $VERSION $DATE"

function usage
{
    echo -e "Usage:
    ./getrevs <option1, option2>\n\n
    \t-h  --help\tShow usage of getrevs\n
    \t-q        \tOnly current SP version checked\n
    \t-e  --extra\tCompare the running FW versions with the Manifest file\n
Both option1 and option2 is optional.\n"
}

if [[ -z "$1" ]] ; then
    usage
    exit 0
fi

FULL=1
EXTRA=0

case $1 in
    "-h"|"--help")
        usage
        exit 0
        ;;
    "-e"|"--extra")
        EXTRA=1
        if [ "$2" == "-q" ] ; then
            FULL=0
        fi
        ;;
    "-q")
        FULL=0
        if [ "$2" == "-e" ] || [ "$2" == "--extra" ] ; then
            EXTRA=1
        fi
        ;;
    *)
        usage
        exit 0
        ;;
esac
        

ERROR=0
WARN=0
########### platforms ########### 
supported_platforms=(HYPERION OBERON BEACHCOMBER BEARCAT)
############ platform specific routines ############
# please define the following routines if adding new platforms (with the newly added platform as the suffix):
#     - get_chassis_type
#       1) please set global variable chassis_type with the chassis type of the platform;
#       2) return 0 (if the chassis type is correct) or 1 if not
#     - set_pci_devices
#       1) ISCSI_BDF: the BDF of iscsi device
#       2) PMC_BDF: the BDF of PMC device
#     - set_wanted_ver
#       1) define MAINLINE_VER: image version which has the good firmware set
#       2) WANTPS: the desired Power Supply version
#       3) WANTBIOS: the desired BIOS version
#       4) WANTPOST: the desired POST version
#       5) TWOSTEPPOST: the version before TWOSTEPPOST needs 2 step to upgrade the post
#       6) WANTBMC:  the desired BMC version
#       7) WANTSSP: the desired SSP version
#       8) WANTCDES: the desired CDES version
#       9) WANTBBU: the desired BBU version
#       10) WANTCM: the desired cooling module version
#       11) WANTHilda: the desired Hilda version
#       12) WANTPMC: the desired PMC SAS FW version
#     - get_bmc: set the variable BMC with the BMC MAIN version
#     - report_fan_fw: define your own functions to report fan fw if any
#     - get_power_supply_part: you need to define the following 3 variables:
#       1) GOOD_PS_PARTS
#       2) BAD_PS_PARTS
#       3) WARN_PS_PARTS
#     - get_board_rev: define the function to report the board part Number of the platform
#     - report_cmd: report the CMDAPP version
#     - get_ssd: define GOOD_SSD_MODELS, BAD_SSD_MODELS, WARN_SSD_MODELS; GOOD_SSD_FW, BAD_SSD_FW, WARN_SSD_FW
#     - report_cpu: report the cpu info for the platform
#     - set_iscsi: set the desired variables for the platform:
#       1) ISCSI_NAME: the name of the ISCSI device
#       2) WANT_ISCSI_VER_NUM: the firmware version of the ISCSI device (in digit)
#       3) WANT_ISCSI_VER: the firmware version of the ISCSI device
#       4) WANT_ISCSI_ID: the device id of the iscsi device

# add new platform routines below

# Hyperion
function get_chassis_type_HYPERION
{
    local rtn=0
    chassis_type=` cat .ip.fru.print | awk ' /^FRU.*ID 2\)/,/^$/' |grep 'Chassis Part Number'|awk '{print $5}'`
    minor_version=`echo $chassis_type | cut -d- -f4`

    if [[ "$chassis_type" =~ "100-565-210" ]] ; then
        echo "OK:    cDVT HYPERION"
    elif [[ "$chassis_type" =~ "100-565-139" ]] ; then
        echo "OK:    DVT HYPERION"
    else
        rtn=1
    fi
    return $rtn
}

function set_pci_devices_HYPERION
{
    ISCSI_BDF="7d:00.0"
    PMC_BDF="81:00.0"
}

function set_wanted_ver_HYPERION
{
    MAINLINE_VER=
    WANTPS=0312
    WANTBIOS=2327
    WANTPOST=0350
    TWOSTEPPOST=0
    WANTBMC=0590
    WANTSSP=0118
    WANTCDES=0.11.1
    WANTBBU=7348
    WANTCM=999999
    WANTCMD=0106
    WANTPMC=0320
}

function get_manifest_ver
{
    Manifest=/var/tmp/*Manifest.txt
    MAINLINE_VER=
    WANTCDES=`xxd -l 100 /EMC/Firmware/cdes_rom.bin | cut -d' ' -f11 | grep -o "[0-9]\.[0-9]\.[0-9]"`
    if [ -f $Manifest ];then
      echo "INFO: Will compare the running FW versions with the Manifest file. "
      Blastoff_DC_Acbel=`cat $Manifest |grep '0x000B0040' |awk -F '|' '{print $4}'|tr -d '.'`
      Optimus_AC_Acbel=`cat $Manifest |grep '0x000B0041' |awk -F '|' '{print $4}'|tr -d '.'`
      Optimus_AC_Flex=`cat $Manifest |grep '0x000B003E' |awk -F '|' '{print $4}'|tr -d '.'`
      WANTBIOS=`cat $Manifest |grep "\<BIOS\>" |grep -v "BIOS ME" |awk -F '|' '{print $4}'|tr -d '.'`
      WANTPOST=`cat $Manifest |grep 'POST' |awk -F '|' '{print $4}'|tr -d '.'`
      TWOSTEPPOST=0
      WANTBMC=`cat $Manifest |grep 'BMC Main'|awk -F '|' '{print $4}'|tr -d '.'`
      WANTSSP=`cat $Manifest |grep 'SSP' |awk -F '|' '{print $4}'|tr -d '.'`
      WANTBBU=`cat $Manifest |grep 'BBU' |awk -F '|' '{print $4}'|tr -d '.'`
      WANTCM=999999
      WANTCMD=`cat $Manifest |grep  'cmd100d815' |awk -F '|' '{print $4}' |awk -F '.' '{print $1$2}'`
      WANTHilda_FC=`cat $Manifest |grep 'fc_oberon_hilda' |grep 'QLOGIC' |awk -F '|' '{print $4}'|tr -d '.'`
      WANTHilda_NIC=`cat $Manifest |grep 'eth_oberon_hilda' |grep 'QLOGIC' | awk -F '|' '{print $4}'|tr -d '.'`
      WANTPMC=`cat $Manifest |grep 'PMC' |grep 'sas_oberon' |awk -F '|' '{print $1}'|awk '{print $NF}'|tr -d '.'`
    else
      echo "INFO: Will compare the running FW versions with FW repository. "
      Blastoff_DC_Acbel=`fw_utility -list|grep blastoff_dc_acbel |cut -d "_" -f7 |cut -d "." -f1`
      Optimus_AC_Acbel=`fw_utility -list|grep optimus_acbel |cut -d "_" -f6 |cut -d "." -f1`
      Optimus_AC_Flex=`fw_utility -list|grep optimus_flex |grep -v 0427|cut -d "_" -f6 |cut -d "." -f1`
      WANTBIOS=`fw_utility -list|grep bios |awk -F "_" '{print $NF}'|cut -d "." -f1`
      WANTPOST=`fw_utility -list|grep post |awk -F "_" '{print $NF}' |cut -d "." -f1`
      TWOSTEPPOST=0
      WANTBMC=`fw_utility -list|grep bmc_main |awk -F "_" '{print $NF}'|cut -d "." -f1`
      WANTSSP=`fw_utility -list|grep ssp |cut -d "_" -f5 |cut -d "." -f1`
      WANTBBU=`fw_utility -list|grep bbu |cut -d "_" -f5 |cut -d "." -f1`
      WANTCM=999999
      WANTCMD=0213
      WANTHilda_FC=`fw_utility -list|grep 'fc_oberon_hilda_[0-9]'|cut -d "_" -f6|cut -d "." -f1`
      WANTHilda_NIC=`fw_utility -list|grep 'eth_oberon_hilda_[0-9]'|cut -d "_" -f6|cut -d "." -f1`
      WANTPMC=`fw_utility -list|grep sas_oberon |cut -d "_" -f5 |cut -d "." -f1`    
    fi
}


function get_bmc_raw_HYPERION
{
    # BMC  raw 0x08 0x01 0x00 0x10 0x00
    BMC=`ipmitool raw 0x08 0x01 0x00 0x10 0x00 | awk '{print strtonum ("0x"$1)strtonum("0x"$2)}'`
}

function get_ssp_raw_HYPERION
{
    # BMC SSP  raw 0x08 0x01 0x00 0x10 0x02
    SSP=`ipmitool raw 0x08 0x01 0x00 0x10 0x02 | awk '{print strtonum ("0x"$1)strtonum("0x"$2)}'`
}

# In Moons, fan is moved to SSP
function report_fan_fw_HYPERION
{
    return
}

function get_power_supply_part_HYPERION
{
    # 071-000-012: Optimus AC Flex : 0x000B0036 (POR)
    # 071-000-036: Optimus AC ACBEL 0x000B0031 (2nd source for Oberon)
    # 071-000-598: Blastoff DC (will not be supported in Oberon POR)
    # 071-000-578: Blastoff AC (will not be supported in Oberon POR)
    # 071-000-555: Octane 875 (only 875w, seems not enough for Oberon)
    GOOD_PS_PARTS=(071-000-036 071-000-012)
    BAD_PS_PARTS=()
    WARN_PS_PARTS=(071-000-598 071-000-578 071-000-555)
}

function get_board_rev_HYPERION
{
    local board_ver=""
    local rtn=0

    rev_spa=`cat .ip.fru.print | awk ' /^FRU.*ID 0\)/,/^$/' | grep 'Board Part Number' | awk '{print $5}'|cut -c 1-12`
    rev_spb=`cat .ip.fru.print | awk ' /^FRU.*ID 1\)/,/^$/' | grep 'Board Part Number' | awk '{print $5}'|cut -c 1-12`


    if [[ "$rev_spa" =~ "A" ]] ; then
        board_ver="A"
    elif [[ "$rev_spa" =~ "B" ]] ; then
        board_ver="B"
    elif [[ "$rev_spa" =~ "C" ]] ; then
        board_ver="C"
    else
        rtn=1
    fi

    if [[ "$rev_spa" != "$rev_spb" ]] ; then
        echo "INFO:  SPA $rev_spa and SPB $rev_spb are different"
    elif [ "$board_ver" != "" ]; then
        echo "OK:    SPA $rev_spa and SPB $rev_spb are same."
    fi

    if [ "$board_ver" != "" ]; then
        if [[ "$rev_spa" =~ "110-325-0" ]] || [[ "$rev_spa" =~ "110-325-1" ]] || [[ "$rev_spa" =~ "110-324-00" ]] ; then
            echo "OK:    Hyperion Rev${board_ver} SP $rev_spa found"
        fi
        if [ $is_new_chassis == 0 ] ; then
            echo "WARN:  Hyperion Rev${board_ver} boards not compatible with the old chassis"
        fi
    fi

    return $rtn
}

function report_cmd_HYPERION
{
    local CMD=`sptool -getspfw |grep CMDAPP | awk '{print $2 }'`
    if [ "$CMD" == "" ]; then
        CMD=`ipmitool raw 0x08 0x01 0x00 0x01 0x00 | awk '{printf("%02d%02d\n", strtonum("0x" $1), strtonum("0x" $2));}'`
    fi
    if [[ "$CMD" < "$WANTCMD" ]] ; then
       echo "ERROR: $SP CMDAPP $CMD is old. Latest version is $WANTCMD. $MAINLINE_VER"
       ERROR=1
    else
          echo "OK:    $SP CMD $CMD is up to date."
    fi
}

function get_ssd_HYPERION
{
    SSDNAME="M.2 SATA"
}

function report_cpu_HYPERION
{
    local cpu_name_cmd="awk -F: '/model name/ {print substr(\$2,0); exit}' /proc/cpuinfo"
    local cpu_name=`eval $cpu_name_cmd`
    echo "OK:    cpu name is $cpu_name"
}

function set_iscsi_HYPERION
{
    ISCSI_NAME="BCM5719"
    WANT_ISCSI_VER_NUM="12370"
    WANT_ISCSI_VER="v1.2.37.0"
    WANT_ISCSI_ID="14e4:1657"
}

function report_Hilda_HYPERION
{
    return
}

function report_pmc_HYPERION
{
    # get PMC
    PMC=`grep -A35 'ID 33' .ip.fru.print | grep -A1 'PMC FW' | grep 'Programmable Revision' | awk ' { print $NF } '`   
    # the device id is 2.w:
    # 02 W DEVICE_ID
    DEVID=`setpci -s $PMC_BDF 2.w`
    # the revision is 8.b: 
    # $ setpci --dumpregs |grep REV    
    #    08 B REVISION
    R=`setpci -s $PMC_BDF 8.b`
    if [ "$PMC" == "" ] ; then
        echo "WARN:  PMC $DEVID Rev $R SAS Firmware version is not available" 
        WARN=1
    elif [ "$PMC" == "$WANTPMC" ] ; then
        echo "OK:    PMC $DEVID Rev $R SAS Firmware version is $PMC"
    else
        echo "ERROR: PMC $DEVID Rev $R SAS Firmware version $PMC is not as expected"
        ERROR=1
    fi
}

function report_ram_status_HYPERION
{
    return 
}

function report_iscsi_HYPERION
{
    report_iscsi_MOONS
}

# Oberon
function get_chassis_type_OBERON
{
    local rtn=0
    chassis_type=` cat .ip.fru.print | awk ' /^FRU.*ID 2\)/,/^$/' | grep 'EMC_System HW TLA PN' | awk '{print $6}'`

    minor_version1=`cat .ip.fru.print | awk ' /^FRU.*ID 2\)/,/^$/' | grep 'EMC_Subassembly PN' | tail -1 | awk '{print $4}' | awk -F '-' '{print $3}'`
    minor_version2=`cat .ip.fru.print | awk ' /^FRU.*ID 1\)/,/^$/' | grep 'EMC_Subassembly PN' | tail -1 | awk '{print $4}' | awk -F '-' '{print $3}'`


    #if [ "R$chassis_type" == "R" ] ; then
    #    WARN=1
    #fi

    # 25 drives
    if [[ "$chassis_type" =~ "100-542-898" ]] ; then
        echo "OK:    OBERON 25DRV 64GB 8C 105W (cDVT)"
    elif [[ "$chassis_type" =~ "100-542-946" ]] ; then
        echo "OK:    OBERON 25DRV 64GB 10C 105W 2.6G (DVT)"
    elif [[ "$chassis_type" =~ "100-542-920" ]] ; then
        echo "OK:    OBERON 25DRV 48GB 8C 85W 2.4G (DVT)"
    elif [[ "$chassis_type" =~ "100-542-921" ]] ; then
        echo "OK:    OBERON 25DRV 24GB 6C 85W 1.6G (DVT)"
    elif [[ "$chassis_type" =~ "100-542-982" ]] ; then
	echo "OK:    OBERON 25DRV 128GB 12C 120W 2.5G (DVT)"
    elif [[ "$chassis_type" =~ "100-542-984" ]] ; then
	echo "OK:    OBERON 25DRV 128GB 12C 120W 2.5G DC (DVT)"

    # 12 drivers
    elif [[ "$chassis_type" =~ "100-542-900" ]] ; then
        echo "OK:    OBERON 12DRV 64GB 8C 105W (cDVT)"
    elif [[ "$chassis_type" =~ "100-542-899" ]] ; then
	echo "OK:    OBERON 12DRV 32GB 6C 85W 1.9G (DVT)"
    elif [[ "$chassis_type" =~ "100-542-947" ]] ; then
        echo "OK:    OBERON 12DRV 64GB 10C 105W 2.6G (DVT)"
    elif [[ "$chassis_type" =~ "100-542-923" ]] ; then
        echo "OK:    OBERON 12DRV 48GB 8C 85W 2.4G (DVT)"
    elif [[ "$chassis_type" =~ "100-542-924" ]] ; then
        echo "OK:    OBERON 12DRV 24GB 6C 85W 1.6G (DVT)"
    elif [[ "$chassis_type" =~ "100-542-983" ]] ; then
	echo "OK:    OBERON 12DRV 128GB 12C 120W 2.5G (DVT)"
    elif [[ "$chassis_type" =~ "100-542-985" ]] ; then
	echo "OK:    OBERON 12DRV 128GB 12C 120W 2.5G DC (DVT)"

    # 25 && 12 drivers
    elif [[ "$chassis_type" =~ "100-542-897" ]] ; then
        if [ "R$minor_version1" == "R" ] ; then
            if [[ "$minor_version2" =~ "000B" || "$minor_version2" == "001B" ]] ; then
                echo "OK:    OBERON 25DRV 32GB 6C 85W (cDVT,Oberon 2)"
            elif [[ "$minor_version2" =~ "000C" || "$minor_version2" =~ "004C" || "$minor_version2" =~ "005C" ]] ; then
                echo "OK:    OBERON 12DRV 32GB 6C 85W 1.9G (DVT,Oberon 2)"
            else
                rtn=1
            fi
        elif [[ "$minor_version1" =~ "000A" || "$minor_version1" =~ "000a" ]] ; then
            echo "OK:    OBERON 12DRV 32GB 6C 85W (cDVT,Oberon 2)"
        elif [[ "$minor_version1" =~ "000B" || "$minor_version1" =~ "000b" ]] ; then
            echo "OK:    OBERON 25DRV 32GB 6C 85W 1.9G (DVT,Oberon 2)"
	elif [[ "$minor_version1" =~ "000C" || "$minor_version1" =~ "000c" ]] ; then
            echo "OK:    OBERON 25DRV 32GB 6C 85W 1.9G (DVT)"
        else
            rtn=1
        fi
    elif [[ "$chassis_type" =~ "100-542-899" ]] ; then
        if [ "R$minor_version1" == "R" ] ; then
            if [[ "$minor_version2" =~ "000B" || "$minor_version2" =~ "001B" ]] ; then
                echo "WARN:  OBERON 25DRV 32GB 6C 85W (cDVT,Oberon 2, not supported any more)"
                WARN=1
            elif [[ "$minor_version2" =~ "000C" || "$minor_version2" =~ "004C" || "$minor_version2" =~ "005C" ]] ; then
                echo "WARN:  OBERON 12DRV 32GB 6C 85W 1.9G (DVT,Oberon 2, not supported any more)"
                WARN=1
            else
                rtn=1
            fi
        elif [[ "$minor_version1" =~ "000A" || "$minor_version1" =~ "000a" ]] ; then
            echo "WARN:  OBERON 25DRV 32GB 6C 85W (cDVT,Oberon 2, not supported any more)"
            WARN=1
        elif [[ "$minor_version1" =~ "000B" || "$minor_version1" =~ "000b" ]] ; then
            echo "WARN:  OBERON 12DRV 32GB 6C 85W 1.9G (DVT,Oberon 2, not supported any more)"
            WARN=1
        else
            rtn=1
        fi
    else
        rtn=1
    fi
    return $rtn    
}

function set_pci_devices_OBERON
{
    ISCSI_BDF="15:00.0"
    PMC_BDF="1d:00.0"
}

function set_wanted_ver_OBERON
{
    Manifest=/EMC/Firmware/Oberon_*_Manifest.txt
    if [ -f $Manifest ] && [ "$EXTRA" == "1" ] ;then
      MAINLINE_VER=
      WANTCDES=`xxd -l 100 /EMC/Firmware/cdes_rom.bin | cut -d' ' -f11 | grep -o "[0-9]\.[0-9]\.[0-9]"`
      echo "INFO: Will compare the running FW versions with the Manifest file. "
      Blastoff_DC_Acbel=`cat $Manifest |grep '0x000B0040' |awk -F '|' '{print $4}'|tr -d '.'`
      Optimus_AC_Acbel=`cat $Manifest |grep '0x000B0041' |awk -F '|' '{print $4}'|tr -d '.'`
      Optimus_AC_Flex=`cat $Manifest |grep '0x000B003E' |awk -F '|' '{print $4}'|tr -d '.'`
      WANTBIOS=`cat $Manifest |grep "\<BIOS\>" |grep -v "BIOS ME" |awk -F '|' '{print $4}'|tr -d '.'`
      WANTPOST=`cat $Manifest |grep 'POST' |awk -F '|' '{print $4}'|tr -d '.'`
      TWOSTEPPOST=0
      WANTBMC=`cat $Manifest |grep 'BMC Main'|awk -F '|' '{print $4}'|tr -d '.'`
      WANTSSP=`cat $Manifest |grep 'SSP' |awk -F '|' '{print $4}'|tr -d '.'`
      WANTBBU=`cat $Manifest |grep 'BBU' |awk -F '|' '{print $4}'|tr -d '.'`
      WANTCM=999999
      WANTCMD=`cat $Manifest |grep  'cmd100d815' |awk -F '|' '{print $4}' |awk -F '.' '{print $1$2}'`
      WANTHilda_FC=`cat $Manifest |grep 'fc_oberon_hilda' |grep 'QLOGIC' |awk -F '|' '{print $4}'|tr -d '.'`
      WANTHilda_NIC=`cat $Manifest |grep 'eth_oberon_hilda' |grep 'QLOGIC' | awk -F '|' '{print $4}'|tr -d '.'`
      WANTPMC=`cat $Manifest |grep 'PMC' |grep 'sas_oberon' |awk -F '|' '{print $1}'|awk '{print $NF}'|tr -d '.'`
    else
      if [ "$EXTRA" == "1" ] ;then
          echo "INFO: No Manifest found. "
      fi
      echo "INFO: Will compare the running FW versions with FW repository. "
      Blastoff_DC_Acbel=`fw_utility -list|grep blastoff_dc_acbel |cut -d "_" -f7 |cut -d "." -f1`
      Optimus_AC_Acbel=`fw_utility -list|grep optimus_acbel |cut -d "_" -f6 |cut -d "." -f1`
      Optimus_AC_Flex=`fw_utility -list|grep optimus_flex |grep -v 0427|cut -d "_" -f6 |cut -d "." -f1`
      WANTBIOS=`fw_utility -list|grep bios |awk -F "_" '{print $NF}'|cut -d "." -f1`
      WANTPOST=`fw_utility -list|grep post |awk -F "_" '{print $NF}' |cut -d "." -f1`
      TWOSTEPPOST=0
      WANTBMC=`fw_utility -list|grep bmc_main |awk -F "_" '{print $NF}'|cut -d "." -f1`
      WANTSSP=`fw_utility -list|grep ssp |cut -d "_" -f5 |cut -d "." -f1`
      WANTBBU=`fw_utility -list|grep bbu |cut -d "_" -f5 |cut -d "." -f1`
      WANTCM=999999
      WANTCMD=0213
      WANTHilda_FC=`fw_utility -list|grep 'fc_oberon_hilda_[0-9]'|cut -d "_" -f6|cut -d "." -f1`
      WANTHilda_NIC=`fw_utility -list|grep 'eth_oberon_hilda_[0-9]'|cut -d "_" -f6|cut -d "." -f1`
      WANTPMC=`fw_utility -list|grep sas_oberon |cut -d "_" -f5 |cut -d "." -f1`    
    fi
}

function get_bmc_raw_OBERON
{
    # BMC  raw 0x08 0x01 0x00 0x10 0x00
    BMC=`ipmitool raw 0x08 0x01 0x00 0x10 0x00 | awk '{print strtonum ("0x"$1)strtonum("0x"$2)}'`
}

function get_ssp_raw_OBERON
{
    # BMC SSP  raw 0x08 0x01 0x00 0x10 0x02
    SSP=`ipmitool raw 0x08 0x01 0x00 0x10 0x02 | awk '{print strtonum ("0x"$1)strtonum("0x"$2)}'`
}

# In Moons, fan is moved to SSP
function report_fan_fw_OBERON
{
    return
}

function get_power_supply_part_OBERON
{
    # 071-000-611-01: Optimus AC Acbel (POR)
    # 071-000-610-01: Optimus AC Flex (POR, 2nd source)
    # 071-000-598-01: Blastoff DC (POR, the only DC)
    # 071-000-578: Blastoff AC (will not be supported in Oberon POR)
    # 071-000-555: Octane 875 (only 875w, seems not enough for Oberon)
    GOOD_PS_PARTS=(071-000-611-01 071-000-610-01 071-000-598-01)
    BAD_PS_PARTS=(071-000-555-01)
    WARN_PS_PARTS=(071-000-610-00 071-000-611-00 071-000-036-03 071-000-012-03 071-000-598-00 071-000-578-01 071-000-609-01)
}

function get_board_rev_OBERON
{
    local board_ver=""
    local rtn=0

    rev_spa=`cat .ip.fru.print | awk ' /^FRU.*ID 0\)/,/^$/' | grep 'Board Part Number' | awk '{print $5}'|cut -c 1-12`
    rev_spb=`cat .ip.fru.print | awk ' /^FRU.*ID 1\)/,/^$/' | grep 'Board Part Number' | awk '{print $5}'|cut -c 1-12`


    if [[ "$rev_spa" =~ "A" ]] ; then
        board_ver="A"
    elif [[ "$rev_spa" =~ "B" ]] ; then
        board_ver="B"
    elif [[ "$rev_spa" =~ "C" ]] ; then
        board_ver="C"
    else
        rtn=1
    fi

    if [[ "$rev_spa" != "$rev_spb" ]] ; then
        echo "INFO:  SPA $rev_spa and SPB $rev_spb are different"
    elif [ "$board_ver" != "" ]; then
        echo "OK:    SPA $rev_spa and SPB $rev_spb are same."
    fi

    if [ "$board_ver" != "" ]; then
        if [[ "$rev_spa" =~ "110-297-00" ]] || [[ "$rev_spa" =~ "204-297-00" ]] || [[ "$rev_spa" =~ "110-297-01" ]] ; then
            echo "OK:    Oberon Rev${board_ver} SP $rev_spa found"
        fi
        if [ $is_new_chassis == 0 ] ; then
            echo "WARN:  Oberon Rev${board_ver} boards not compatible with the old chassis"
        fi
    fi

    return $rtn
}

function report_cmd_OBERON
{
    local CMD=`sptool -getspfw |grep CMDAPP | awk '{print $2 }'`
    if [ "$CMD" == "" ]; then
        CMD=`ipmitool raw 0x08 0x01 0x00 0x01 0x00 | awk '{printf("%02d%02d\n", strtonum("0x" $1), strtonum("0x" $2));}'`
    fi
    if [[ "$CMD" < "$WANTCMD" ]] ; then
       echo "ERROR: $SP CMDAPP $CMD is old. Latest version is $WANTCMD. $MAINLINE_VER"
       ERROR=1
    else
          echo "OK:    $SP CMD $CMD is up to date."
    fi
}

function get_ssd_OBERON
{
    SSDNAME="M.2 SATA"
}

function report_cpu_OBERON
{
    local cpu_name_cmd="awk -F: '/model name/ {print substr(\$2,0); exit}' /proc/cpuinfo"
    local cpu_name=`eval $cpu_name_cmd`
    echo "OK:    cpu name is $cpu_name"
}

function set_iscsi_OBERON
{
    ISCSI_NAME="Twinville"
    WANT_ISCSI_VER_NUM="08000054"
    WANT_ISCSI_VER="0x8000054a"
    WANT_ISCSI_ID="8086:1528"
}

function report_Hilda_OBERON
{
    #get Hilda
    num=`lspci | grep -i qlogic | grep "19:00"|wc -l`
    if [ "$num" == 2 ] ; then
        WANTHilda=$WANTHilda_FC
	model="FC mode"
    elif [ "$num" == 6 ] ; then
        WANTHilda=$WANTHilda_NIC
	model="NIC mode"
    fi
    Hilda=`grep -A1 'QLOGICFW' .ip.fru.print.localsp | tail -1 | awk ' { print $NF }'`
    if [ "$Hilda" == "" ] ; then
        Hilda=`grep  'QLOGICFW' /var/tmp/.sptool.getspfw|awk '{print $2}'`
    fi

    #check Hilda
    if [ "$Hilda" == "" ] ; then
        echo "WARN:  $SP Hilda Firmware verion is not available."
    elif [ "0$Hilda" -lt "0$WANTHilda" ] ; then
        echo "ERROR: $SP Hilda $Hilda is old. Need $WANTHilda.${MAINLINE_VER}" 
        ERROR=1
    elif [ "$Hilda" -gt "9900" ] ; then
            echo "WARN:  $SP Hilda $Hilda is experimental.Need $WANTHilda.Manual update required.See wiki$WIKID"
            WARN=1
    else
            echo "OK:    $SP Hilda($model) $Hilda is up to date"
    fi
}

function report_pmc_OBERON
{
    # get PMC
    PMC=`grep -A1 'PMC FW' .ip.fru.print.localsp | grep 'Programmable Revision' | awk ' { print $NF } '`

    # the device id is 2.w:
    # 02 W DEVICE_ID
    DEVID=`setpci -s $PMC_BDF 2.w`
    # the revision is 8.b: 
    # $ setpci --dumpregs |grep REV    
    #    08 B REVISION
    R=`setpci -s $PMC_BDF 8.b`
    if [ "$PMC" == "" ] ; then
        echo "WARN:  PMC $DEVID Rev $R SAS Firmware version is not available" 
        WARN=1
    elif [ "$PMC" -lt "$WANTPMC" ] ; then
        echo "ERROR: PMC $DEVID Rev $R SAS Firmware version $PMC is old. Need $WANTPMC."
        ERROR=1
    else
        echo "OK:    PMC $DEVID Rev $R SAS Firmware version $PMC is up to date."
    fi
}

function report_ram_status_OBERON
{
    local mb
   
    if [[ -z `dmidecode -t memory | sed -ne 's/^[\t]*Size: \([0-9]\+\) MB.*$/\1/p'` ]]; then
        for mb in `dmidecode -t memory | sed -ne 's/^[\t]*Size: \([0-9]\+\) GB.*$/\1/p'`; do
            let total+=$mb
        done
    else 
        for mb in `dmidecode -t memory | sed -ne 's/^[\t]*Size: \([0-9]\+\) MB.*$/\1/p'`; do
            let total+=$mb
        done
        let total/=1024 
    fi
    #let total/=1024

    # Check RAM status
    if [ $total -eq 24 ]; then
        echo "OK:    24GB Memory found"
    elif [ $total -eq 32 ]; then
        echo "OK:    32GB Memory found"
     elif [ $total -eq 48 ]; then
        echo "OK:    48GB Memory found"
    elif [ $total -eq 64 ]; then
        echo "OK:    64GB Memory found"
    elif [ $total -eq 96 ]; then
        echo "OK:    96GB Memory found"
    elif [ $total -eq 128 ]; then
	echo "OK:    128GB Memory found"
    elif [ $total -eq 256 ]; then
        echo "OK:    256GB Memory found"
    else
        echo "WARN:  Unknown memory configuration"
    fi
}

function report_iscsi_OBERON
{
    report_iscsi_MOONS
}


### BEACHCOMBER start ###
function get_chassis_type_BEACHCOMBER
{
    local rtn=0
    chassis_type=` cat .ip.fru.print | awk ' /^FRU.*ID 1\)/,/^$/' |grep 'Chassis Part Number'|awk '{print $5}'`

    if [[ "$chassis_type" =~ "100-542-441" ]] ; then
        echo "OK:    Chassis Type is Ramhorn (25 drive Beachcomber)"
    elif [[ "$chassis_type" =~ "100-542-400" ]] ; then
        echo "OK:    Chassis Type is Ramhorn (25 drive Beachcomber)"
    elif [[ "$chassis_type" =~ "100-542-455" ]] ; then
        echo "OK:    Chassis Type is SteelJaw (12 drive Beachcomber)"
    elif [[ "$chassis_type" =~ "100-542-460" ]] ; then
        echo "OK:    Chassis Type is SteelJaw (12 drive Beachcomber)"
    elif [[ "$chassis_type" =~ "100-542-465" ]] ; then
        echo "OK:    Chassis Type is SteelJaw (12 drive Beachcomber)"
    elif [[ "$chassis_type" =~ "100-542-446" ]] ; then
        echo "OK:    Chassis Type is SteelJaw (12 drive Beachcomber)"
    else
        rtn=1
    fi
    return $rtn
}

function set_pci_devices_BEACHCOMBER
{
    PMC_BDF="34:00.0"
}

function set_wanted_ver_BEACHCOMBER
{
    MAINLINE_VER="Need Mainline-20130911 or later."
    WANTPS_BLASTOFF=0303
    WANTPS_OCTANE=0905
    WANTBIOS=2260
    WANTPOST=5070
    TWOSTEPPOST=3071
    WANTBMC=1420
    WANTSSP=0173
    WANTCDES=1502
    WANTBBU=0653
    WANTCM=0190
    WANTCMD=0809
    WANTPMC=0218
}

function get_bmc_raw_BEACHCOMBER
{
    return
}

function get_ssp_raw_BEACHCOMBER
{
    return
}

# other Transformers don't have fan fw, it is controlled by BMC.
function report_fan_fw_BEACHCOMBER
{
    # check Fan firmware of devices with Ramhorn/Steeljaw chassis
        local_fan0_fw=`$IPMITOOL raw 0x30 0x92 0x1 0x1 0x58 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 | awk '{printf("%02d%02d\n", strtonum("0x" $4), strtonum("0x" $5));}'`
        local_fan1_fw=`$IPMITOOL raw 0x30 0x92 0x1 0x1 0x5A 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 | awk '{printf("%02d%02d\n", strtonum("0x" $4), strtonum("0x" $5));}'`
        local_fan2_fw=`$IPMITOOL raw 0x30 0x92 0x1 0x1 0x54 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 | awk '{printf("%02d%02d\n", strtonum("0x" $4), strtonum("0x" $5));}'`
        peer_fan0_fw=`$IPMITOOL raw 0x30 0x92 0x1 0x2 0x58 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 | awk '{printf("%02d%02d\n", strtonum("0x" $4), strtonum("0x" $5));}'`
        peer_fan1_fw=`$IPMITOOL raw 0x30 0x92 0x1 0x2 0x5A 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 | awk '{printf("%02d%02d\n", strtonum("0x" $4), strtonum("0x" $5));}'`
        peer_fan2_fw=`$IPMITOOL raw 0x30 0x92 0x1 0x2 0x54 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 | awk '{printf("%02d%02d\n", strtonum("0x" $4), strtonum("0x" $5));}'`

	if [[ "$local_fan0_fw" == "$local_fan1_fw" ]] && [[ "$local_fan0_fw" == "$local_fan2_fw" ]] && [[ "$local_fan0_fw" == "$peer_fan0_fw" ]] && [[ "$local_fan0_fw" == "$peer_fan1_fw" ]] && [[ "$local_fan0_fw" == "$peer_fan2_fw" ]] ; then
	    if [[ "$local_fan0_fw" < "$WANTCM" ]] ; then
		echo "ERROR: Cooling Module MCU firmware $local_fan0_fw is old, requires manual update.  See wiki11107"
		ERROR=1
	    else 
		echo "OK:    Cooling Module MCU firmware $local_fan0_fw "
	    fi
	else
	    if [[ "$local_fan0_fw" < "$WANTCM" ]] ; then
		echo "INFO: Local Cooling Module 0 MCU firmware $local_fan0_fw is old, requires manual update.  See wiki11107"
	    else
		echo "OK:   Local Cooling Module 0 MCU firmware $local_fan0_fw is up to date"
	    fi
	    if [[ "$local_fan1_fw" != "$local_fan0_fw" ]] ; then
		echo "INFO: MCU firmware for local cooling module 1 is not same as local cooling module 0 ($local_fan1_fw != $local_fan0_fw)"
	    fi
	    if [[ "$local_fan2_fw" != "$local_fan0_fw" ]] ; then
		echo "INFO: MCU firmware for local cooling module 2 is not same as local cooling module 0 ($local_fan2_fw != $local_fan0_fw)"
	    fi
	    if [[ "$peer_fan0_fw" != "$local_fan0_fw" ]] ; then
		echo "INFO: MCU firmware for peer cooling module 0 is not same as local cooling module 0 ($peer_fan0_fw != $local_fan0_fw)"
	    fi
	    if [[ "$peer_fan1_fw" != "$local_fan0_fw" ]] ; then
		echo "INFO: MCU firmware for peer cooling module 1 is not same as local cooling module 0 ($peer_fan1_fw != $local_fan0_fw)"
	    fi
	    if [[ "$peer_fan2_fw" != "$local_fan0_fw" ]] ; then
		echo "INFO: MCU firmware for peer cooling module 2 is not same as local cooling module 0 ($peer_fan2_fw != $local_fan0_fw)"
	    fi
	fi
}

function get_power_supply_part_BEACHCOMBER
{
    GOOD_PS_PARTS=(071-000-591-03 071-000-022-00)
    BAD_PS_PARTS=(071-000-999-00)
    WARN_PS_PARTS=(071-000-589-00 071-000-578-01 071-000-555-01 071-000-597-00 071-000-591-04)
}

function get_board_rev_BEACHCOMBER
{
    local rtn=0

    rev_spa=`cat .ip.fru.print | awk ' /^FRU.*ID 2\)/,/^$/' | grep 'Board Part Number' | awk '{print $5}'|cut -c 1-12`
    rev_spb=`cat .ip.fru.print | awk ' /^FRU.*ID 4\)/,/^$/' | grep 'Board Part Number' | awk '{print $5}'|cut -c 1-12`

    # Check Rev B/C/D
    if [[ "$rev_spa" =~ "D" ]] ; then
        echo "OK:    RevD SP found"

        if [ $is_new_chassis == 0 ] ; then
            echo "WARN:  RevD boards not compatible with Knot/Boxwood chassis"
        fi
    elif [[ "$rev_spa" =~ "B" ]] ; then
        echo "OK:    RevB SP found"
        if [ $is_new_chassis == 1 ] ; then
            echo "WARN:  RevB boards not compatible with Ramhorn/Steeljaw chassis"
        fi
    elif [[ "$rev_spa" =~ "C" ]] ; then
        if [[ "$rev_spa" =~ "110-124-000C " ]] ; then
            echo "ERROR: Board 110-124-000C is eHornet, cannot be in slot A"
        else
            echo "OK:    RevC SP found"
            if [ $is_new_chassis == 0 ] ; then
                echo "WARN:  RevC boards not compatible with Knot/Boxwood chassis"
            fi
        fi
    else
        rtn=1
    fi

    return $rtn
}

function report_cmd_BEACHCOMBER
{
    local CMD=`sptool -getspfw |grep CMDAPP | awk '{print $2 }'`
    if [[ "$CMD" < "$WANTCMD" ]] ; then
       echo "ERROR: $SP CMDAPP $CMD is old. Latest version is $WANTCMD. Need Mainline-201403042202 or later."
       ERROR=1

       if [[ "$rev_spa" =~ "B" ]]||[[ "$rev_spb" =~ "B" ]] ; then
            echo "       Rev. B system need to manually upgrade CMD FW. See document: http://c4server6a.rtp.lab.emc.com/dist/Firmware/Beachcomber/."
       elif [[ "$bpn" == "110-333-000" ]] ; then
               echo "       System with eLandslide need to manually upgrade CMD FW. See document: http://c4server6a.rtp.lab.emc.com/dist/Firmware/Beachcomber/."
       fi
    else
          echo "OK:    $SP CMD $CMD is up to date."
    fi
}

function get_ssd_BEACHCOMBER
{
    SSDNAME="mSATA"
}

function report_cpu_BEACHCOMBER
{
    GOOD_CPU_MODELS=(E5606 E5620 C3528 C3539)
    BAD_CPU_MODELS=(C5518)

    # Check CPU model
    local cpu_model_cmd="awk '/model name/ {print \$7; exit}' /proc/cpuinfo"
    local cpu_model_number=`eval $cpu_model_cmd`
    if [ -n "$cpu_model_number" ]; then
        check_results $cpu_model_number GOOD_CPU_MODELS BAD_CPU_MODELS
        result=$?
    if [ $result -eq 1 ]; then
        echo "ERROR: CPU model number $cpu_model_number is not supported."
        echo "       Please SWAP it before you continue with your operation."
        echo "       Following are supported models:${GOOD_CPU_MODELS[@]}"
        ERROR=1
    elif [ $result -eq 2 ]; then
        echo "WARN:  CPU $cpu_model_number is not supported."
    elif [ $result -eq 3 ]; then
        cpu_name_cmd="awk -F: '/model name/ {print substr(\$2,0); exit}' /proc/cpuinfo"
        cpu_name=`eval $cpu_name_cmd`
        echo "OK:    CPU model: $cpu_model_number, cpu name is $cpu_name"
    fi
    else
        echo "Unable to check the CPU model. Failed to run cmd: $cpu_model_cmd"
    fi
    echo $cpu_model_number | grep -q -e E5-2430 -e E5-1428 && echo "OK:    6 core CPU"
    echo $cpu_model_number | grep -q -e E5-2430 -e E5-1428 && grep -q maxcpus=4 /proc/cmdline && echo "INFO:  NMI will fail with maxcpus=4.  See wiki12551 to change."
    echo $cpu_model_number | grep -q -e E5-2407 && echo "OK:    4 core CPU"
}

function report_Hilda_BEACHCOMBER
{
    return
}

function report_pmc_BEACHCOMBER
{
    # get PMC
    PMC=`grep -A1 'CNTLFW' .ip.fru.print.localsp | grep 'Programmable Revision' | awk ' { print $NF } '| uniq`
    # the device id is 2.w:
    # 02 W DEVICE_ID
    DEVID=`setpci -s $PMC_BDF 2.w`
    # the revision is 8.b: 
    # $ setpci --dumpregs |grep REV    
    #    08 B REVISION
    R=`setpci -s $PMC_BDF 8.b`
    if [ "$PMC" == "" ] ; then
        echo "WARN:  PMC $DEVID Rev $R SAS Firmware version is not available" 
        WARN=1
    elif [ "$PMC" -lt "$WANTPMC" ] ; then
        echo "ERROR: PMC $DEVID Rev $R SAS Firmware version $PMC is old. Need $WANTPMC."
        ERROR=1
    else
        echo "OK:    PMC $DEVID Rev $R SAS Firmware version $PMC is up to date."
    fi
}

function report_ram_status_BEACHCOMBER
{
    local mem
    local total=0
    for mem in `dmidecode -t 17 | sed -ne 's/^[\t]*Size: \([0-9]\+\) MB.*$/\1/p'`; do
        let total+=$mem
    done

    let total/=1024

    # Check RAM status
    if [ $total -eq 12 ]; then
        echo "ERROR: 12GB Memory found - new standard is 24G."
        ERROR=1
    elif [ $total -eq 24 ]; then
        echo "OK:    24GB Memory found"
    elif [ $total -eq 32 ]; then
        echo "OK:    32GB Memory found"
    else
        echo "WARN:  Unknown memory configuration"
    fi
}

function report_iscsi_BEACHCOMBER
{
    local WANTBF=7.6.55
    local WANTBD_ID=14e4:16a1
    # Check Beachcomber specific: Broadcom Firmware, Device ID, MAC Addresses
    broadcom_chip=`setpci -s 24:0.0 8.b`
    if [[ "$broadcom_chip" == "10" ]] ; then
        B="B0"
    elif [[ "$broadcom_chip" == "11" ]] ; then
        B="B1"
    fi

    #check whether eth2 is present and mapped to 24:00
    eth2_map24=`ls -l /sys/class/net | grep eth2 |grep -c 24:00`

    if [[ "$eth2_map24" == "0" ]] ; then
        echo "WARN:  This systems don't have eth2 configured, or it is configured with a 5709 or different device."
    else
        br_eth2=`ethtool -i eth2 | grep firmware-version | awk '{print $3}'`
        br_eth3=`ethtool -i eth3 | grep firmware-version | awk '{print $3}'`
        br_eth4=`ethtool -i eth4 | grep firmware-version | awk '{print $3}'`
        br_eth5=`ethtool -i eth5 | grep firmware-version | awk '{print $3}'`

        broadcom_eth2=`ethtool -i eth2 | grep firmware-version | awk '{print $3}' | tr -d '.'`
        broadcom_eth3=`ethtool -i eth3 | grep firmware-version | awk '{print $3}' | tr -d '.'`
        broadcom_eth4=`ethtool -i eth4 | grep firmware-version | awk '{print $3}' | tr -d '.'`
        broadcom_eth5=`ethtool -i eth5 | grep firmware-version | awk '{print $3}' | tr -d '.'`
        if [[ "$broadcom_eth2" == "$broadcom_eth3" && "$broadcom_eth2" == "$broadcom_eth4" && "$broadcom_eth2" == "$broadcom_eth5" ]]; then
            if [[ "$br_eth2" < "$WANTBF" ]] ; then
                echo "ERROR: Broadcom 57840 $B Firmware $br_eth2 is old. It has to be $WANTBF. See wiki10891"
            else
                echo "OK:    Broadcom 57840 $B Firmware is $br_eth2"
            fi

        else
            if [[ "$br_eth2" < "$WANTBF" ]] ; then
                echo "ERROR: Broadcom 57840 $B Firmware for eth2 $br_eth2 is old. It has to be $WANTBF. See wiki10891"
            else
                echo "OK:    Broadcom 57840 $B Firmware for eth2 is $br_eth2"
            fi

            if [[ "$broadcom_eth3" != "$broadcom_eth2" ]]; then
                echo "WARN:  Broadcom 57840 $B Firmware for eth3 $br_eth3 is not the same as eth2"
                ERROR=1
            fi

            if [[ "$broadcom_eth4" != "$broadcom_eth2" ]]; then
                echo "WARN:  Broadcom 57840 $B Firmware for eth4 $br_eth4 is not the same as eth2"
                ERROR=1
            fi

            if [[ "$broadcom_eth5" != "$broadcom_eth2" ]]; then
                echo "WARN:  Broadcom 57840 $B Firmware for eth5 $br_eth5 is not the same as eth2"
                ERROR=1
            fi
        fi

    fi

    # Check Broadcom Device ID
    broadcom_id=`lspci -s 24:00.0  -n | awk '{print $3}'`
    if [[ "$broadcom_id" != "$WANTBD_ID" ]] ; then
    echo "ERROR: Broadcom Device ID is $broadcom_id. It has to be $WANTBD_ID."
    fi

    # Check error in MAC Address
    eth2_config=`ls -l /sys/class/net|grep -c eth2`
    if [[ "$eth2_config" == 0 ]] ; then
        echo "WARN:  Ports eth2-eth5 have no carrier"
    else
        mac_eth2=`ifconfig eth2 | grep HWaddr | awk '{ print substr( $5, 10) }'`
        mac_eth3=`ifconfig eth3 | grep HWaddr | awk '{ print substr( $5, 10) }'`
        mac_eth4=`ifconfig eth4 | grep HWaddr | awk '{ print substr( $5, 10) }'`
        mac_eth5=`ifconfig eth5 | grep HWaddr | awk '{ print substr( $5, 10) }'`

        if [[ "$mac_eth2" == "00:00:00" ]] ; then
            echo "ERROR: MAC Address of eth2 contains all zeros"
        fi

        if [[ "$mac_eth3" == "00:00:00" ]] ; then
            echo "ERROR: MAC Address of eth3 contains all zeros"
        fi

        if [[ "$mac_eth4" == "00:00:00" ]] ; then
            echo "ERROR: MAC Address of eth4 contains all zeros"
        fi

        if [[ "$mac_eth5" == "00:00:00" ]] ; then
            echo "ERROR: MAC Address of eth5 contains all zeros"
        fi
    fi
}


### BEARCAT start ###
function get_chassis_type_BEARCAT
{
    local rtn=0
    chassis_type=` cat .ip.fru.print | awk ' /^FRU.*ID 1\)/,/^$/' |grep 'Chassis Part Number'|awk '{print $5}'`

    if [[ "$chassis_type" =~ "100-542-441-05" ]] ; then
        echo "OK:    BEARCAT  Assy 25DRV Chassis, MDPL, PS, Coolimg Mod "
    elif [[ "$chassis_type" =~ "100-542-442" ]] ; then
        echo "OK:    BEARCAT  Assy 25DRV Chassis, MDPL, PS, Coolimg Mod"
    elif [[ "$chassis_type" =~ "100-542-446-06" ]] ; then
        echo "OK:    BEARCAT  Assy 12DRV Chassis, MDPL, PS, Coolimg Mod"
    else
        rtn=1
    fi
    return $rtn
}

function set_pci_devices_BEARCAT
{
    PMC_BDF="34:00.0"
}

function set_wanted_ver_BEARCAT
{
    MAINLINE_VER=""
    WANTPS_BLASTOFF=0306
    WANTPS_OCTANE=0905   
    WANTBIOS=0130
    WANTPOST=0170
    TWOSTEPPOST=3071
    WANTBMC=0131
    WANTSSP=0100
    WANTCDES=1514
    WANTBBU=0653
    WANTCM=0190
    WANTCMD=0809
    WANTPMC=0218
    WANTHilda_FC=0140
    WANTHilda_NIC=0150
}

function get_bmc_raw_BEARCAT
{
    return
}

function get_ssp_raw_BEARCAT
{
    return
}

# other Transformers don't have fan fw, it is controlled by BMC.

function report_fan_fw_BEARCAT
{
        # check Fan firmware of devices with chassis_type
    if [[ "$chassis_type" =~ "100-542-44" ]] || [[ "$chassis_type" =~ "303-281-000A-00" ]] ; then
        local_fan0_fw=`$IPMITOOL raw 0x30 0x92 0x1 0x1 0x58 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 | awk '{printf("%02d%02d\n", strtonum("0x" $4), strtonum("0x" $5));}'`
	local_fan1_fw=`$IPMITOOL raw 0x30 0x92 0x1 0x1 0x5A 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 | awk '{printf("%02d%02d\n", strtonum("0x" $4), strtonum("0x" $5));}'`
	local_fan2_fw=`$IPMITOOL raw 0x30 0x92 0x1 0x1 0x54 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 | awk '{printf("%02d%02d\n", strtonum("0x" $4), strtonum("0x" $5));}'`
	peer_fan0_fw=`$IPMITOOL raw 0x30 0x92 0x1 0x2 0x58 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 | awk '{printf("%02d%02d\n", strtonum("0x" $4), strtonum("0x" $5));}'`
	peer_fan1_fw=`$IPMITOOL raw 0x30 0x92 0x1 0x2 0x5A 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 | awk '{printf("%02d%02d\n", strtonum("0x" $4), strtonum("0x" $5));}'`
	peer_fan2_fw=`$IPMITOOL raw 0x30 0x92 0x1 0x2 0x54 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 | awk '{printf("%02d%02d\n", strtonum("0x" $4), strtonum("0x" $5));}'`
    fi

        if [[ "$local_fan0_fw" == "$local_fan1_fw" ]] && [[ "$local_fan0_fw" == "$local_fan2_fw" ]] && [[ "$local_fan0_fw" == "$peer_fan0_fw" ]] && [[ "$local_fan0_fw" == "$peer_fan1_fw" ]] && [[ "$local_fan0_fw" == "$peer_fan2_fw" ]] ; then
	    if [[ "$local_fan0_fw" < "$WANTCM" ]] ; then
		echo "ERROR: Cooling Module MCU firmware $local_fan0_fw is old, requires manual update.  See wiki11107"
                ERROR=1
            else
                echo "OK:    Cooling Module MCU firmware $local_fan0_fw "
            fi
        else
            if [[ "$local_fan0_fw" < "$WANTCM" ]] ; then
                echo "INFO: Local Cooling Module 0 MCU firmware $local_fan0_fw is old, requires manual update.  See wiki11107"
            else
                echo "OK:   Local Cooling Module 0 MCU firmware $local_fan0_fw is up to date"
            fi
            if [[ "$local_fan1_fw" != "$local_fan0_fw" ]] ; then
                echo "INFO: MCU firmware for local cooling module 1 is not same as local cooling module 0 ($local_fan1_fw != $local_fan0_fw)"
            fi
            if [[ "$local_fan2_fw" != "$local_fan0_fw" ]] ; then
                echo "INFO: MCU firmware for local cooling module 2 is not same as local cooling module 0 ($local_fan2_fw != $local_fan0_fw)"
            fi
            if [[ "$peer_fan0_fw" != "$local_fan0_fw" ]] ; then
                echo "INFO: MCU firmware for peer cooling module 0 is not same as local cooling module 0 ($peer_fan0_fw != $local_fan0_fw)"
            fi
            if [[ "$peer_fan1_fw" != "$local_fan0_fw" ]] ; then
                echo "INFO: MCU firmware for peer cooling module 1 is not same as local cooling module 0 ($peer_fan1_fw != $local_fan0_fw)"
            fi
            if [[ "$peer_fan2_fw" != "$local_fan0_fw" ]] ; then
                echo "INFO: MCU firmware for peer cooling module 2 is not same as local cooling module 0 ($peer_fan2_fw != $local_fan0_fw)"
            fi
        fi   
}

function get_power_supply_part_BEARCAT
{
    GOOD_PS_PARTS=(071-000-591-03 071-000-022-00)
    BAD_PS_PARTS=(071-000-999-00)
    WARN_PS_PARTS=(071-000-589-00 071-000-578-01 071-000-555-01 071-000-597-00 071-000-591-04)
}

function get_board_rev_BEARCAT
{
        local rtn=0

    rev_spa=`cat .ip.fru.print | awk ' /^FRU.*ID 2\)/,/^$/' | grep 'Board Part Number' | awk '{print $5}'|cut -c 1-12`
    rev_spb=`cat .ip.fru.print | awk ' /^FRU.*ID 4\)/,/^$/' | grep 'Board Part Number' | awk '{print $5}'|cut -c 1-12`

    # Check Rev A/B/C/D
    if [[ "$rev_spa" =~ "A" ]] ; then
        echo "OK:    RevA SP found"
    elif [[ "$rev_spa" =~ "D" ]] ; then
        echo "OK:    RevD SP found"

        if [ $is_new_chassis == 0 ] ; then
            echo "WARN:  RevD boards not compatible with Knot/Boxwood chassis"
        fi
    elif [[ "$rev_spa" =~ "B" ]] ; then
        echo "OK:    RevB SP found"
        if [ $is_new_chassis == 1 ] ; then
            echo "WARN:  RevB boards not compatible with Ramhorn/Steeljaw chassis"
        fi
    elif [[ "$rev_spa" =~ "C" ]] ; then
        if [[ "$rev_spa" =~ "110-124-000C " ]] ; then
            echo "ERROR: Board 110-124-000C is eHornet, cannot be in slot A"
        else
            echo "OK:    RevC SP found"
            if [ $is_new_chassis == 0 ] ; then
                echo "WARN:  RevC boards not compatible with Knot/Boxwood chassis"
            fi
        fi
    else
        rtn=1
    fi

    return $rtn 
}

function report_cmd_BEARCAT
{
    local CMD=`sptool -getspfw |grep CMDAPP | awk '{print $2 }'`
    if [[ "$CMD" < "$WANTCMD" ]] ; then
       echo "ERROR: $SP CMDAPP $CMD is old. Latest version is $WANTCMD."
       ERROR=1

       if [[ "$rev_spa" =~ "B" ]]||[[ "$rev_spb" =~ "B" ]] ; then
            echo "       Rev. B system need to manually upgrade CMD FW. See document: http://c4server6a.rtp.lab.emc.com/dist/Firmware/Beachcomber/."
       elif [[ "$bpn" == "110-333-000" ]] ; then
               echo "       System with eLandslide need to manually upgrade CMD FW. See document: http://c4server6a.rtp.lab.emc.com/dist/Firmware/Beachcomber/."
       fi
    else
          echo "OK:    $SP CMD $CMD is up to date."
    fi
}

function get_ssd_BEARCAT
{
    SSDNAME="mSATA"
}

function report_cpu_BEARCAT
{
    GOOD_CPU_MODELS=(E5606 E5620 C3528 C3539)
    BAD_CPU_MODELS=(C5518)

    # Check CPU model
    local cpu_model_cmd="awk '/model name/ {print \$7; exit}' /proc/cpuinfo"
    local cpu_model_number=`eval $cpu_model_cmd`
    if [ -n "$cpu_model_number" ]; then
        check_results $cpu_model_number GOOD_CPU_MODELS BAD_CPU_MODELS
        result=$?
    if [ $result -eq 1 ]; then
        echo "ERROR: CPU model number $cpu_model_number is not supported."
        echo "       Please SWAP it before you continue with your operation."
        echo "       Following are supported models:${GOOD_CPU_MODELS[@]}"
        ERROR=1
    elif [ $result -eq 2 ]; then
        echo "WARN:  CPU $cpu_model_number is not supported."
    elif [ $result -eq 3 ]; then
        cpu_name_cmd="awk -F: '/model name/ {print substr(\$2,0); exit}' /proc/cpuinfo"
        cpu_name=`eval $cpu_name_cmd`
        echo "OK:    CPU model: $cpu_model_number, cpu name is $cpu_name"
    fi
    else
        echo "Unable to check the CPU model. Failed to run cmd: $cpu_model_cmd"
    fi
    echo $cpu_model_number | grep -q -e E5-2430 -e E5-1428 && echo "OK:    6 core CPU"
    echo $cpu_model_number | grep -q -e E5-2430 -e E5-1428 && grep -q maxcpus=4 /proc/cmdline && echo "INFO:  NMI will fail with maxcpus=4.  See wiki12551 to change."
    echo $cpu_model_number | grep -q -e E5-2407 && echo "OK:    4 core CPU"
}

function report_Hilda_BEARCAT
{
        #get Hilda
    num=`lspci | grep -i qlogic|wc -l`
    if [ "$num" == 2 ] ; then
        WANTHilda=$WANTHilda_FC
	model="FC model"
    elif [ "$num" == 6 ] ; then
        WANTHilda=$WANTHilda_NIC
	model="NIC model"
    fi
    Hilda=`grep -A1 'QLOGICFW' .ip.fru.print.localsp | tail -1 | awk ' { print $NF }'`
    if [ "$Hilda" == "" ] ; then
        Hilda=`grep  'QLOGICFW' /var/tmp/.sptool.getspfw|awk '{print $2}'`
    fi

    #check Hilda
    if [ "$Hilda" == "" ] ; then
        echo "WARN:  $SP Hilda Firmware verion is not available."
    elif [ "0$Hilda" -lt "$WANTHilda" ] ; then
        echo "ERROR: $SP Hilda $Hilda is old. Need $WANTHilda.${MAINLINE_VER}" 
        ERROR=1
    elif [ "$Hilda" -gt "9900" ] ; then
            echo "WARN:  $SP Hilda $Hilda is experimental.Need $WANTHilda.Manual update required.See wiki$WIKID"
            WARN=1
    else
            echo "OK:    $SP Hilda($model) $Hilda is up to date"
    fi
}

function report_pmc_BEARCAT
{
    # get PMC
    PMC=`grep -A1 'CNTLFW' .ip.fru.print.localsp | grep 'Programmable Revision' | awk ' { print $NF } '| uniq`
    # the device id is 2.w:
    # 02 W DEVICE_ID
    DEVID=`setpci -s $PMC_BDF 2.w`
    # the revision is 8.b: 
    # $ setpci --dumpregs |grep REV    
    #    08 B REVISION
    R=`setpci -s $PMC_BDF 8.b`
    if [ "$PMC" == "" ] ; then
        echo "WARN:  PMC $DEVID Rev $R SAS Firmware version is not available" 
        WARN=1
    elif [ "$PMC" -lt "$WANTPMC" ] ; then
        echo "ERROR: PMC $DEVID Rev $R SAS Firmware version $PMC is old. Need $WANTPMC."   
        ERROR=1
    else
        echo "OK:    PMC $DEVID Rev $R SAS Firmware version $PMC is up to date."
    fi
}

function report_ram_status_BEARCAT
{
    # Check RAM status
    # Bearcat has 8GB memory 
    mem=0; 
    for mem0 in `dmidecode -t memory | grep Size | grep MB | cut -f2 -d' '`; 
    do mem=`expr $mem + $mem0`; 
    done; 

    if [ $mem -eq 8192 ]; then
        echo "OK:    8GB Memory found"
    else
        echo "WARN:  Unknown memory configuration"
	WARN=1
    fi
}

function report_iscsi_BEARCAT
{
    return ;
}

########### families ###########
supported_families=(MOONS TRANSFORMERS)
############ family specific routines ##############
# please define the following routines if adding new family (with the newly added family as the suffix):
#   - set_fru_id: set the FRU IDs for the families:
#       1) LOCALSP: the localsp id
#   - set_wiki_id: set the WIKIID with wiki id for upgrading fw
#   - get_system_type: set system_type with the system type of the family
#   - report_power_supply_mcu: report the power supply version for the family
#   - report_iscsi: report the iscsi interface info for the family
#   - get_slic: get the slic info for the family:
#   - report_ram_status: check the system ram configuration
#   - get_cdes_version: set cdes with the CDES version for the family

# add new family below


function report_iscsi_MOONS
{
    set_iscsi_$CPLAT
    ### check ISCSI Device on Oberon platform. Assuming ports are eth0 and eth1
    # Check Intel ISCSI firmware
    eth0_config=`ls -l /sys/class/net|grep -c eth0`
    if [[ "$eth0_config" != 0 ]] ; then
        iscsi_eth0=`ethtool -i eth0 | grep firmware-version | awk '{print $NF}'`
        iscsi_eth1=`ethtool -i eth1 | grep firmware-version | awk '{print $NF}'`
    else
        eth2_config=`ls -l /sys/class/net|grep -c eth2`
        if [[ "$eth2_config" != 0 ]] ; then
            iscsi_eth0=`ethtool -i eth2 | grep firmware-version | awk '{print $NF}'`
            iscsi_eth1=`ethtool -i eth3 | grep firmware-version | awk '{print $NF}'`
        fi
    fi

    iscsi_eth0=`echo $iscsi_eth0 |sed 's/[[:alpha:]]//g' |tr -d '.' | tr -d '-'`
    iscsi_eth1=`echo $iscsi_eth1 |sed 's/[[:alpha:]]//g' |tr -d '.' | tr -d '-'`

    if [[ "$iscsi_eth0" != "$iscsi_eth1" ]]; then
        echo "WARN:    $ISCSI_NAME Firmware for eth0=$iscsi_eth0 (Got from ethtool) is not the same as eth1=$iscsi_eth1"
    fi

    if [[ "$iscsi_eth0" < "$WANT_ISCSI_VER_NUM" ]] ; then
        echo "ERROR:    $ISCSI_NAME Firmware for eth0=$iscsi_eth0 (Got from ethtool) is old. It has to be $WANT_ISCSI_VER"
        ERROR=1
    elif [[ "$iscsi_eth1" < "$WANT_ISCSI_VER_NUM" ]] ; then
        echo "ERROR:    $ISCSI_NAME Firmware for eth1=$iscsi_eth1 (Got from ethtool) is old. It has to be $WANT_ISCSI_VER"
        ERROR=1
    else
        echo "OK:    $ISCSI_NAME Firmware $iscsi_eth0 (Got from ethtool) is up to date"
    fi

    # Check ISCSI Device ID
    iscsi_id=`lspci -s $ISCSI_BDF  -n | awk '{print $3}'`
    if [[ "$iscsi_id" != "$WANT_ISCSI_ID" ]] ; then
        echo "ERROR: $ISCSI_NAME Device ID is $iscsi_id. It has to be $WANT_ISCSI_ID."
    fi

    # Check error in MAC Address
    eth0_config=`ls -l /sys/class/net|grep -c eth0`
    if [[ "$eth0_config" == 0 ]] ; then
        echo "OK:    Ports eth0-eth1 have no carrier"
        eth0_config=`ls -l /sys/class/net|grep -c eth2`
        if [[ "$eth0_config" == 0 ]] ; then
            echo "WARN:  Ports eth2-eth3 have no carrier"
        else
            mac_eth0=`ip addr show eth2 | grep link\/ether | awk '{print substr ($2, 10)}'`
            mac_eth1=`ip addr show eth3 | grep link\/ether | awk '{print substr ($2, 10)}'`
            echo "OK:    Ports eth2-eth3 have carrier"
        fi
    else
        mac_eth0=`ip addr show eth0 | grep link\/ether | awk '{print substr ($2, 10)}'`
        mac_eth1=`ip addr show eth1 | grep link\/ether | awk '{print substr ($2, 10)}'`
        echo "INFO:  Ports eth0-eth1 have carrier"
    fi

    if [[ "$mac_eth0" == "00:00:00" ]] ; then
        echo "ERROR: MAC Address of eth0 contains all zeros"
    elif [[ "$mac_eth0" == "60:16:00" ]] ; then
        echo "ERROR: Twinville MAC address is missing"
    elif [[ "$mac_eth1" == "00:00:00" ]] ; then
        echo "ERROR: MAC Address of eth1 contains all zeros"
    elif [[ "$mac_eth1" == "60:16:00" ]] ; then
        echo "ERROR: Twinville MAC address is missing"
    else
        echo "OK:    MAC addresses are good on those carriers"
    fi
}


function set_fru_id_MOONS
{
    LOCALSP=0
}

function set_wiki_id_MOONS
{
    WIKIID=13839
}

function get_system_type_MOONS
{
    lo=`ipmitool raw 0x30 0x78 | awk '{print $1}'`
    high=`ipmitool raw 0x30 0x78 | awk '{print $2}'`
    system_type=${high}${lo}
}

function report_power_supply_mcu_MOONS
{
    local PS_MCU_SP;
    if [[ $SP == "SPA" ]] ; then
	PS_MCU=`speclcli -getPsStatus | awk '/'$SP' PS0 Status/,/^$/' |grep Firmware |head -n 1|awk '{print $NF}'|tr -d '.'`
    else
        PS_MCU=`speclcli -getPsStatus | awk '/'$SP' PS0 Status/,/^$/' |grep Firmware| head -n 2|awk '{print $NF}'|tr -d '.'`
    fi
    if [[ "$ps_part_number" == "071-000-611-01" ]] ; then
       if [[ "$PS_MCU" < "$Optimus_AC_Acbel" ]] ; then
          echo "ERROR: $SP Power supply firmware version $PS_MCU is old. Need $Optimus_AC_Acbel."
          ERROR=1
       else
          echo "OK:    $SP Power supply firmware version $PS_MCU is up to date"
       fi
    elif [[ "$ps_part_number" == "071-000-610-01" ]] ; then  
       if [[ "$PS_MCU" < "$Optimus_AC_Flex" ]] ; then
          echo "ERROR: $SP Power supply firmware version $PS_MCU is old. Need $Optimus_AC_Flex."
          ERROR=1
       else
          echo "OK:    $SP Power supply firmware version $PS_MCU is up to date"
       fi
    elif [[ "$ps_part_number" == "071-000-598-01" ]] ; then
       if [[ "$PS_MCU" < "$Blastoff_DC_Acbel" ]] ; then
          echo "ERROR: $SP Power supply firmware version $PS_MCU is old. Need $Blastoff_DC_Acbel."
          ERROR=1
       else
          echo "OK:    $SP Power supply firmware version $PS_MCU is up to date"
       fi	   
    fi
}

function get_slic_MOONS
{
    slic_0_fru=`cat .ip.fru.print | sed -n '/SLIC0/,/SLIC1/p' |grep "EMC_FRU/Family ID" |awk -F ": " '{print $2}' | tr [a-z] [A-Z]`
    peer_slic_0_fru=`sptool -r  slic0 peer | grep "Family FRU ID" |awk -F ":" '{print $2}'|awk -F " " '{print substr($2,3,6)substr($1,3,6)}' | tr [a-z] [A-Z]`

    slic_1_fru=`cat .ip.fru.print | grep -A30 SLIC1 |grep "EMC_FRU/Family ID" |awk -F ": " '{print $2}' |tr [a-z] [A-Z]`
    peer_slic_1_fru=`sptool -r  slic1 peer | grep "Family FRU ID" |awk -F ":" '{print $2}'|awk -F " " '{print substr($2,3,6)substr($1,3,6)}' |tr [a-z] [A-Z]`

    slictype=(
        DownburstX,000C0023
        MaelstromX,000A0023
        RockslideX,00050023
        SnowdevilX,00040023
        ThunderheadX,00070023
        VortexQX,00060023
        )

    slics=(
       SLIC0,$slic_0_fru,$peer_slic_0_fru
       SLIC1,$slic_1_fru,$peer_slic_1_fru
       )

}

function get_cdes_version_MOONS
{
    Fbecli enclstrout -b 0 -e 0 -cmd version > /dev/null
    cdes=`Fbecli enclstrin -b 0 -e 0 | grep "Main:" | awk '{print $2}'`
}

function report_bbu_MOONS
{
    local BBUREVLOCAL_1=`ipmitool raw 0x08 0x01 0x09 0x03 0x00 | awk '{printf("%02d\n", strtonum("0x" $1))}'`
    local BBUREVLOCAL_2=`ipmitool raw 0x08 0x01 0x09 0x03 0x00 | awk '{printf("%02d\n", strtonum("0x" $2))}'`
    local BBUREVLOCAL=`echo $BBUREVLOCAL_1$BBUREVLOCAL_2`
    
    # Check BBU Version
    local TEMPREVLOCAL=`echo $BBUREVLOCAL` 
    local TEMPWANTEDREV=`echo $WANTBBU `
    if [ "0$TEMPREVLOCAL" -lt "0$TEMPWANTEDREV"  ] ; then
        echo "ERROR: Local BBU firmware version $BBUREVLOCAL is old!  $WANTBBU or newer recommended"
        ERROR=1
    elif [ "0$TEMPREVLOCAL" == "0$TEMPWANTEDREV" ] ; then
        echo "OK:    Local BBU firmware version $BBUREVLOCAL is up to date"
    else 
        echo "WARN:  Local BBU firmware version $BBUREVLOCAL is not as expected"
        Warn=1
    fi
}

function set_fru_id_TRANSFORMERS
{
    LOCALSP=2
}

function set_wiki_id_TRANSFORMERS
{
    WIKIID=10837
}

function get_system_type_TRANSFORMERS
{
    system_type=` cat .ip.fru.print | awk ' /^FRU.*ID 1\)/,/^$/' |grep 'EMC_System Type'|awk '{print $NF}'`
}

function report_power_supply_mcu_TRANSFORMERS
{
    local PS_MCU=`speclcli -getPsStatus | awk '/'$SP' PS0 Status/,/^$/' |grep Firmware|awk '{print $NF}'|tr -d '.'`
    if [[ "$ps_part_number" == "071-000-022-00" ]] ; then
       if [[ "$PS_MCU" < "$WANTPS_OCTANE" ]] ; then
          echo "ERROR: $SP Power supply firmware version $PS_MCU is old. Need $WANTPS_OCTANE."
          ERROR=1
       else
          echo "OK:    $SP Power supply firmware version $PS_MCU is up to date"
       fi
    elif [[ "$ps_part_number" == "071-000-591-03" ]] ; then
       if [[ "$PS_MCU" < "$WANTPS_BLASTOFF" ]] ; then
          echo "ERROR: $SP Power supply firmware version $PS_MCU is old. Need $WANTPS_BLASTOFF."
          ERROR=1
       else
          echo "OK:    $SP Power supply firmware version $PS_MCU is up to date"
       fi
    fi

}

function get_slic_TRANSFORMERS
{
    eslic_fru=`cat .ip.fru.print | grep -A30 eSLIC |grep "EMC_FRU/Family ID" |awk -F ": " '{print $2}' | tr [a-z] [A-Z]`
    peer_eslic_fru=`sptool -r  slic0 peer | grep "Family FRU ID" |awk -F ":" '{print $2}'|awk -F " " '{print substr($2,3,6)substr($1,3,6)}' | tr [a-z] [A-Z]`

    slictype=(
        eGlacier,000B0014
        eSupercell,000A0014
        eLandslide,00140014
        eEruption,00100014
        )

    slics=(
        eSLIC,$eslic_fru,$peer_eslic_fru
        )

}

function get_cdes_version_TRANSFORMERS
{
    cdes=`Fbecli enclstat | grep "Bus:0 Enclosure:0" | grep BundleRev | head -1 | awk '{ field = $NF }; END{ print field }' | cut -d: -f2`
}

function report_bbu_TRANSFORMERS
{
    local BBUREVLOCAL=`grep -A4 "BBU" /var/tmp/.sptool.r.all | grep 'Programmable Revision' | awk '{print $NF}' |sed  -n '1p'`
    # Check BBU Version
    local TEMPREVLOCAL=`echo $BBUREVLOCAL`
    local TEMPWANTEDREV=`echo $WANTBBU `
    if [ "0$TEMPREVLOCAL" -lt "0$TEMPWANTEDREV"  ] ; then
        echo "ERROR: Local BBU firmware version $BBUREVLOCAL is old!  $WANTBBU or newer recommended"
        ERROR=1
    elif [ "0$TEMPREVLOCAL" == "0$TEMPWANTEDREV"  ] ; then
        echo "OK:    Local BBU firmware version $BBUREVLOCAL is up to date"
    else
        echo "WARN:  Local BBU firmware version $BBUREVLOCAL is not as expected"
        Warn=1
    fi
}

############ unknown family/platform routines ############
function set_wiki_id_UNKNOWN
{
    return
}

function get_chassis_type_UNKNOWN
{
    return
}

function set_pci_devices_UNKNOWN
{
    ISCSI_BDF=""
    PMC_BDF=""
}

function set_wanted_ver_UNKNOWN
{
    echo "ERROR: UNKNOWN PLATFORM - $PLATFORM"
    echo "WARN:  Continuing, but results not guaranteed."
    MAINLINE_VER=
    WANTPS=999999
    WANTBIOS=999999
    WANTPOST=999999
    TWOSTEPPOST=0
    WANTBMC=999999
    WANTSSP=999999
    WANTCDES=999999
    WANTBBU=999999
    WANTCM=999999
    WANTCMD=999999
    WANTHilda_FC=999999
    WANTHilda_NIC=999999
    WANTPMC=999999
}

function report_power_supply_mcu_UNKNOWN
{
    return
}

function report_iscsi_UNKNOWN
{
    return
}

function get_board_rev_UNKNOWN
{
    return
}

function report_cmd_UNKNOWN
{
    return
}

function get_bmc_raw_BEACHCOMBER
{
    return
}

function get_ssp_raw_BEACHCOMBER
{
    return
}

function get_system_type_UNKNOWN
{
    return
}

function report_fan_fw_UNKNOWN
{
    return
}

function get_power_supply_part_UNKNOWN
{
    return
}

function get_ssd_UNKNOWN
{
    return
}

function report_cpu_UNKNOWN
{
    return
}

function get_slic_UNKNOWN
{
    return
}


function report_ram_status_UNKNOWN
{
    return
}

function get_cdes_version_UNKNOWN
{
    return
}

function report_Hilda_UNKNOWN
{
    return
}

function report_bbu_UNKNOWN
{
    return
}

function report_pmc_UNKNOWN
{
    return
}

############ main process ################

# never touch it unless you need to fix bugs or add new checkers.
function create_cache_files
{
    ### Start by caching some slow operations
    IPMITOOL=`which ipmitool`
    $IPMITOOL fru print $LOCALSP > .ip.fru.print.localsp
    $IPMITOOL fru print > .ip.fru.print
    $IPMITOOL lan print > .ip.lan.print

    sptool -i > .sptool.i
    # Check if the stack is up, if so collect a bunch of info
    # We need a special check for gnosis
    STACK_UP=`pstree | grep safe | wc -l`
    if [ "$STACK_UP" != "0" ] ; then
        SP=`cat .sptool.i`
        speclcli -forceresumeread 0
        speclcli -forceresumeread 19
        sptool -r all > /var/tmp/.sptool.r.all
        sptool -getspfw > /var/tmp/.sptool.getspfw
    else
        echo "ERROR: Can not check all revisions unless the SAFE Stack is running"
        touch  /var/tmp/.sptool.r.all
        touch /var/tmp/.sptool.getspfw
        ERROR=1
    fi
}

function cleanup_cache_files
{
    rm -f .ip.fru.print.localsp
    rm -f .ip.fru.print
    rm -f .ip.lan.print
    rm -f .sptool.i
    rm -f /var/tmp/.sptool.r.all
    rm -f /var/tmp/.sptool.getspfw
}



function build_family_data
{
    CFAM="UNKNOWN"
    FAMILY=`sptool -f | awk ' {print $1 }'`
    for fam in ${supported_families[*]}; do
        if [ "$fam" == "$FAMILY" ]; then
            CFAM=$FAMILY
        fi
    done

    set_fru_id_$CFAM
    set_wiki_id_$CFAM
}



function build_platform_data
{
    CPLAT="UNKNOWN"
    PLATFORM=`sptool -P | awk ' {print $2 }'`
    if [ "$PLATFORM" == "OBERON" ] ; then
        Prefix_dir="Oberon"
    elif [ "$PLATFORM" == "BEACHCOMBER" ] ; then
	local  index=`ipmitool fru list 2 | grep 'EMC_FRU/Family ID' | awk -F ':' '{print $2}'`
	if [[ "$index" =~ "000a0019" ]] ; then
	    PLATFORM="BEARCAT"
            Prefix_dir="Bearcat"
	else
	    PLATFORM="BEACHCOMBER"
            Prefix_dir="Beachcomber"
	fi 
    fi	    
    for plat in ${supported_platforms[*]}; do
        if [ "$plat" == "$PLATFORM" ]; then
            CPLAT=$PLATFORM
        fi
    done
    # Get manifest file from c4server6a server (10.6.96.65)
    #if [ $FULL == 1 ] ; then
    #   rm -f /var/tmp/$Prefix_dir_*_Manifest.txt &> /dev/null
    #   wget -r -np -nd --tries=1 --timeout=3 -q --accept="Manifest.txt" http://10.6.96.65/dist/Firmware/$Prefix_dir/Latest/
    #fi
    set_pci_devices_$CPLAT
    set_wanted_ver_$CPLAT
}

function report_platform
{
    # get PLATFORM
    echo "OK:    This is an $PLATFORM"
}

function report_sp
{
    SP=`cat .sptool.i`

    echo "OK:    Report for $SP"
}

function report_version
{
    # determine version and branch of running image
    cat /.version >> /dev/null 2>&1
    if [ -f /.version ] ; then
      FVERSION=`cat /.version`
    else
      if [ -f /mnt/ssdroot/.version ] ; then
        FVERSION=`cat /mnt/ssdroot/.version`
      else 
        if [ -f /.version-bootflash ] ; then
          FVERSION=`cat /.version-bootflash`
        else
          echo "WARN:  No /.version file found"
          FVERSION="0.0.0.0"
        fi
      fi
    fi
    echo "OK:    Version is $FVERSION"


# help LabOps figure out if the code on the array is suitable for use with
#  the 611 Optimus power supplies (or with 4K drives in the system slots)

    if [ $PLATFORM == "OBERON" ] ; then
   	Check_FVERSION=`echo $FVERSION | cut -d- -f1`
	Stream_Flag=1
	PS_Flag=1
	Drive_Flag=1
    	if [[ $Check_FVERSION =~ "upc_platdev_cs" ]]; then
        	Compare_Version=`echo $FVERSION | cut -d- -f2 | cut -d. -f 1-4`
        	if [ $Compare_Version \< "4.0.0.5770203 " ] ; then
                	PS_Flag=0
                	Drive_Flag=0
        	fi

   	elif [[ $Check_FVERSION =~ "upc_platdev_mcs" ]]; then
        	Compare_Version=`echo $FVERSION | cut -d- -f2 | cut -d. -f 1-4`
        	if [ $Compare_Version \< "4.0.0.5793093 " ] ; then
                	PS_Flag=0
                	Drive_Flag=0
        	fi

   	elif [[ $Check_FVERSION =~ "upc_apps_cs" ]]; then
        	Compare_Version=`echo $FVERSION | cut -d- -f2 | cut -d. -f 1-4`
        	if [ $Compare_Version \< "4.0.0.5803554 " ]  ; then
                	PS_Flag=0
        	fi
        	if [ $Compare_Version \< "4.0.0.5762490 " ]  ; then
                	Drive_Flag=0
        	fi

    	elif [[ $Check_FVERSION =~ "upc_apps_mcs" ]] ; then
        	Compare_Version=`echo $FVERSION | cut -d- -f1 | cut -d_ -f4 `
        	if [ $Compare_Version \< "201507091701" ] ; then
                	PS_Flag=0
        	fi
        	if [ $Compare_Version \< "201507111701" ] ; then
                	Drive_Flag=0
        	fi
    	elif [[ $Check_FVERSION =~ "upc_Unity" ]] ; then
         	Compare_Version=`echo $FVERSION | cut -d- -f1 | cut -d_ -f4 `
        	if [ $Compare_Version \< "201507100500" ] ; then
                	PS_Flag=0
        	fi

        	if [ $Compare_Version \< "201507020500" ] ; then
                	Drive_Flag=0
         	fi
    	else
        	Stream_Flag=0
	fi
	if [ $Stream_Flag -eq 1 ] ; then
    		if [ $PS_Flag -eq 1 ] ; then
        		echo "INFO:  This SP can use the 611 Optimus power supply."
    		elif [ $PS_Flag -eq 0 ] ; then
        		echo "INFO:  This SP can't use the 611 Optimus power supply."
    		fi

    		if [ $Drive_Flag -eq 1 ] ; then
        		echo "INFO:  This SP can use 4K drives in the system slots."
    		elif [ $Drive_Flag -eq 0 ] ; then
        		echo "INFO:  This SP can't use 4K drives in the system slots."
    		fi
	else
		echo "INFO:  This SP is running an image from a user stream or private image,  no check for 611 Optimus power supply/4K drive ."
	fi
    fi

}

# Display Chassis Type
function report_chassis
{
    is_new_chassis=1

    get_chassis_type_$CPLAT

    if [ $? -ne 0 ]; then
        echo "ERROR: Unknown chassis type \"$chassis_type\""    
        ERROR=1
        is_new_chassis=0
        WANTCDES=0
    fi
}

function report_system_type
{
    get_system_type_$CFAM
    if [[ "$system_type" =~ "0007" ]] ; then
        echo "OK:    System type is ISC (0007)"
    else
        echo "WARN:  System type ($system_type) should be 0007 (ISC).  See wiki11806"
    fi
}

function report_post
{
    # Check POST  
    POST=`grep -A1 POST  .ip.fru.print.localsp | tail -1 | awk ' { print $NF } '`
    if [ "$POST" == "" ] ; then
      POST=`grep  POST /var/tmp/.sptool.getspfw|awk '{print $2}'`
        if [ "$POST" == "" ] ; then
            echo "ERROR: Failed to get POST version. resume is not programmed and safe is not up"
            ERROR=1
            return
        fi
    fi

    if [ "0$POST" -lt "$WANTPOST" ] ; then
        if [ "0$POST" -lt "$TWOSTEPPOST" ] ; then
            echo "ERROR: $SP POST $POST is V9.0 or older.  Need two step upgrade.  See wiki$WIKIID"
        fi
       echo "ERROR: $SP POST $POST is old. Need $WANTPOST. ${MAINLINE_VER}"
       ERROR=1
    else
       if [ "$POST" -gt "9900" ] ; then
           echo "WARN:  $SP POST $POST is experimental. Need $WANTPOST. Manual update required. See wiki$WIKIID"
           WARN=1
       else
           echo "OK:    $SP POST $POST is up to date"
       fi
    fi

}

function report_bmc
{ 
    BMC=`grep -A1 "BMC MAIN"  .ip.fru.print.localsp | tail -1 | awk ' { print $NF } '`
    if [ "$BMC" == "" ] ; then 
        BMC=`grep 'BMC MAIN' /var/tmp/.sptool.getspfw|awk '{print $3}'`
        if [ "$BMC" == "" ]; then
            get_bmc_raw_$CPLAT
        fi
    fi

    if [[ "$BMC" < "$WANTBMC" ]] ; then
       echo "ERROR: $SP BMC $BMC is old. Need $WANTBMC. ${MAINLINE_VER}"
       ERROR=1
    else
       if [[ "$BMC" > "9900" ]] ; then
           echo "WARN:  $SP BMC $BMC is experimental. Need $WANTBMC. Manual update required. See wiki$WIKIID"
           WARN=1
       else
           echo "OK:    $SP BMC $BMC is up to date"
       fi
    fi
}

function report_ssp
{
    # get BMC SSP
    SSP=`grep -A1 "BMC SSP"  .ip.fru.print.localsp | tail -1 | awk ' { print $NF } '`
    if [ "$SSP" == "" ] ; then 
        SSP=`grep 'BMC SSP' /var/tmp/.sptool.getspfw|awk '{print $3}'`   
        if [ "$SSP" == "" ] ; then 
            get_ssp_raw_$CPLAT
        fi
    fi

    # Check SSP
    if [[ "$SSP" < "$WANTSSP" ]] ; then
       echo "ERROR: $SP SSP $SSP is old. Need $WANTSSP. See wiki$WIKIID"
       ERROR=1
    else
       echo "OK:    $SP SSP $SSP is up to date"
    fi
}

function report_bios
{
    # get BIOS
    BIOS=`cat .ip.fru.print.localsp | grep -v ME |grep -A1 BIOS | tail -1 | awk ' { print $NF }'`
    if [ "$BIOS" == "" ] ; then 
        BIOS=`cat /var/tmp/.sptool.getspfw|grep -v ME |grep  BIOS |awk '{print $2}'`
        if [ "$BIOS" == "" ] ; then 
        BIOS=`dmidecode | grep 'BIOS Revision' | awk '{print $NF}' | tr -d '.'`
        fi
    fi

    # Check BIOS
    if [ "0$BIOS" -lt "$WANTBIOS" ] ; then
       echo "ERROR: $SP BIOS $BIOS is old. Need $WANTBIOS. ${MAINLINE_VER}"
       ERROR=1
    else
       if [ "$BIOS" -gt "9900" ] ; then
           echo "WARN:  $SP BIOS $BIOS is experimental. Need $WANTBIOS. Manual update required. See wiki$WIKIID"
           WARN=1
       else
           echo "OK:    $SP BIOS $BIOS is up to date"
       fi
    fi
}

function report_bmc_mac
{
    # Check BMC MAC Address, IP Address and IP Address Source 
    mac_add=`cat .ip.lan.print | grep 'MAC Address' | awk '{print $4}'`
    ip_address=`cat .ip.lan.print | grep "^IP Address  " | awk ' { print $4 } ' `
    ip_assignment=`cat .ip.lan.print | grep 'IP Address Source' | awk '{print $5}'`
    echo "OK:    BMC MAC Address is $mac_add"
    echo "OK:    BMC IP Assignment is $ip_assignment"

    if [[ "$ip_address" == "0.0.0.0" ]] ; then
    echo "ERROR: BMC IP Address contains all zeros"
    else
    echo "OK:    BMC IP Address is $ip_address"
    fi
}

function report_board_rev
{
    get_board_rev_$CPLAT

    if [ $? -ne 0 ]; then
        echo "ERROR: Error in Board Part Number $rev_spa."
    fi
}

function report_tco_wdog
{
    # Check if TCO works

    grep -q "NO_REBOOT flag is not programmable" /var/log/boot.msg 2> /dev/null
    if [ $? == 0 ] ; then 
        echo "INFO:  TCO watchdog cannot reboot system.  May see hangs on some watchdog conditions."
    else
        echo "OK:    TCO watchdog can reboot system."
    fi
}

function report_cdes
{
    # Check CDES Version
    get_cdes_version_$CFAM
    if [[ "$cdes" != "" ]] ; then
       for (( i=1;i<=3;i++ ))
       do
            v1=`echo $cdes | cut -d '.' -f $i`
            v2=`echo $WANTCDES | cut -d '.' -f $i`
            if [[ "$v1" -eq "$v2" ]] && [[ "$i" -ne "3" ]];then
                    continue
            elif [[ "$v1" -lt "$v2" ]];then
                    echo "WARN:  CDES Version $cdes not expected.  Want $WANTCDES"
                    break
            else
                    echo "OK:    CDES Version is $cdes"
                    break
            fi
        done
    else
        echo "WARN:  CDES Version not found, possibly because SAS stack isn't up yet."
    fi
}

function report_slic
{
    get_slic_$CFAM

    local total_slics=${#slics[*]}
    local inter_slics=0
    local total_types=0
    local inter_types=0
    while [ $inter_slics -lt $total_slics ]
    do
      slic_type=""
      slot=`echo ${slics[inter_slics]} |awk -F "," '{print $1}'`
      slic_fru=`echo ${slics[inter_slics]} |awk -F "," '{print $2}'`

      if [ "$slic_fru" != "" ] ; then
        total_types=${#slictype[*]}
        inter_types=0
        while [ $inter_types -lt $total_types ]
        do
          echo ${slictype[inter_types]} |grep "$slic_fru"  > /dev/null
          if [ $? -eq 0 ]; then
             slic_type=` echo ${slictype[inter_types]} |grep "$slic_fru" | awk -F "," '{print $1}'`
          fi
          (( inter_types++ ))
        done
        if [ "$slic_type" != "" ] ; then
              echo "OK:    $slot is $slic_type. "
        else
           echo "ERROR: Unknown $slot found. FRU ID is $slic_fru. "
           ERROR=1
        fi
      fi
      (( inter_slics++ ))
    done
    compare_slic_with_peer
}

# Compare SLICs configuration on local sp and peer sp
function compare_slic_with_peer
{
    local slic_num=${#slics[*]}
    local inter=0

    while [ $inter -lt $slic_num ]
    do
      slot=`echo ${slics[inter]} |awk -F "," '{print $1}'`
      slic_fru=`echo ${slics[inter]} |awk -F "," '{print $2}'`
      peer_slic_fru=` echo ${slics[inter]} |awk -F "," '{print $3}'`
      if [ "$peer_slic_fru" != "$slic_fru" ] ; then
         if [ "$STACK_UP" != "0" ] ; then
            echo "ERROR: $slot mismatch found on local and peer sp: $slic_fru != $peer_slic_fru."
            ERROR=1
         else
            echo "WARN:  Unable to get peer $slot due to SAFE not up. "
            WARN=1
         fi
      else
        if  [ "$peer_slic_fru" != "" ] ; then
         echo "OK:    $slot configuration is consistent on local and peer sp. "
        fi
      fi
      (( inter++ ))
    done
}


# Power supply Part Numbers
# Check a set of data against a list of good 
# and optionally bad versions
function check_results
{
    result=$1

    OLD_IFS=$IFS
    IFS=''

    local array_string="$2[*]"
    local good=(${!array_string})

    local array_string="$3[*]"
    local bad=(${!array_string})

    local array_string="$4[*]"
    local warn=(${!array_string})

    IFS=$OLD_IFS

    length_of_good=${#good[@]}
    length_of_bad=${#bad[@]}
    length_of_warn=${#warn[@]}

    if [ $length_of_good -ge 0 ]; then
        for part in ${good[@]}
        do
            [ $result = $part ] && return 0
        done
        unset part
        if [ $length_of_bad -ge 0 ]; then
            for part in ${bad[@]}
            do
                [ $result = $part ] && return 1
            done
            unset part
            if [ $length_of_warn -ge 0 ]; then
                for part in ${warn[@]}
                do
                    [ $result = $part ] && return 2
                done
                unset part
            fi
        fi
    fi
    return 3
}

function report_power_supply_part
{
    get_power_supply_part_$CPLAT
    
    # Check Power Supply Parts

    #17:36:39 root@BC-R1037-spa spa:/var/tmp> ipmitool fru list 5
    # Board Mfg Date        : Wed Aug 15 23:00:00 2012
    # Board Mfg             : ACBEL POLYTECH INC.
    # Board Product         : 12V P/S WITH 12VSTBY AND FAN
    # Board Serial          : AC7B9122509938
    # Board Part Number     : 071-000-589-00

    spa_ps_part_cmd="ipmitool fru list 5 |grep 'Board Part Number'|awk '{print \$NF}'"
    spb_ps_part_cmd="ipmitool fru list 6 |grep 'Board Part Number'|awk '{print \$NF}'"
    if [ $SP == "SPA" ]; then
	ps_part_number=`eval $spa_ps_part_cmd`
    else
	ps_part_number=`eval $spb_ps_part_cmd`
    fi
    if [ -n "$ps_part_number" ]; then
        check_results $ps_part_number GOOD_PS_PARTS BAD_PS_PARTS WARN_PS_PARTS
        result=$?
        if [ $result -eq 1 ]; then
            echo "ERROR: Power supply part number $ps_part_number is not supported."
            echo "       Please SWAP it before you continue with your operation."
            echo "       Following are supported Power supply parts:${GOOD_PS_PARTS[@]}"
            ERROR=1
        elif [ $result -eq 0 ]; then
            echo "OK:    Power supply $ps_part_number is supported."
        elif [ $result -eq 2 ]; then
            echo "WARN:  Power supply $ps_part_number is not supported for ship. OK for lab use."
        elif [ $result -eq 3 ]; then
            echo "WARN:  Unknown Power supply: $ps_part_number"
        fi
    else
        if [ "$is_new_chassis" == 1 ] ; then
           echo "Unable to check the power supply parts. Failed to run cmd: $ps_part_cmd"
        fi
    fi
}

function report_ssd
{
    get_ssd_$CPLAT

    #-- Check for the SSD model
    ssdmodel=`hdparm -i /dev/ssd | sed -ne 's/^.*Model=\([A-Za-z0-9\ ]*\),.*/\1/p'`
    
    #-- Find the current SSD firmware version
    current_ssd_fw=`hdparm -I /dev/ssd |grep -i Firmware | awk '{print $3}'`

    SSDMODEL=(
	mSATA,SmartModular,PS3107,SGMST3D32GBM01EMC,118033093,Ver7.02w
	mSATA,SmartModular,PS3107,SGMST3D32GBM02EMC,118033111,Ver7.02w
 	mSATA,SmartModular,PS3108,SHMST6D032GHM11EMC,118000100,S8FM08.2
 	mSATA,SmartModular,PS3108,SHMST6D032GHM01EMC,118000089,S8FM08.2
        M.2,SmartModular,PS3108,SHM2S6D032GHM01EMC,118000005,S8FM08.2
 	M.2,SmartModular,PS3108,SHM2S6D064GHM01EMC,118000006,S8FM08.2
        M.2,SmartModular,PS3108,SHM2S6D128GHM01EMC,118000007,S8FM08.2
 	M.2,SmartModular,PS3108,SHM2S6D256GHM01EMC,118000042,S8FM08.2
	M.2,SmartModular,PS3108,SHM2S6D032GHM11EMC,118000105,S8FM08.2
 	M.2,SmartModular,PS3108,SHM2S6D064GHM11EMC,118000106,S8FM08.2
	M.2,SmartModular,PS3108,SHM2S6D128GHM11EMC,118000107,S8FM08.2
 	M.2,SmartModular,PS3108,SH9M2S66D032GHM01,none,S8FM08.2
        M.2,SmartModular,PS3108,SH9M2S66D064GHM01,none,S8FM08.2
	M.2,Intel,S3500,937481,118000039,G201EM04
 	M.2,Intel,S3500,937482,118000039,G201EM04

	# Be careful with the space!
 	M.2,Intel,S3500,"INTEL SSDSCKHB080G4M",118000039,G201EM04
	M.2,Intel,S3500,"INTEL SSDSCKHB120G4M",118000040,G201EM04
 	)
   
    # search the SSD model
    local cnt=${#SSDMODEL[@]}
    local i=0
	while [ $i -lt $cnt ]
	    do
            temp_model=`echo ${SSDMODEL[i]} |awk -F "," '{print $4}'`
            echo $ssdmodel | grep "$temp_model" > /dev/null
	    if [ $? -eq 0 ]; then
		vendor=`echo ${SSDMODEL[i]} |awk -F "," '{print $2}'`
		seriesname=`echo ${SSDMODEL[i]} |awk -F "," '{print $3}'`
		latest_ssd_fw=`echo ${SSDMODEL[i]} |awk -F "," '{print $6}'`
		break
	    fi
	    (( i++ ))
	done
    
    # check if the SSD model is supported.
    if [ ! -n "$seriesname" ]; then
	echo "ERROR: unsupported SSD model: $ssdmodel."
        ERROR=1
        return
    else
	echo "OK:    Current SSD model is: $ssdmodel"
    fi


    if [[ "$current_ssd_fw" > "$latest_ssd_fw" ]] || [[ "$current_ssd_fw" = "$latest_ssd_fw" ]]; then
        echo "OK:    Current SSD firmware $current_ssd_fw is up to date."
    else
        echo "WARN:  $SSDNAME firmware $current_ssd_fw is not supported for ship, please upgrade it to $latest_ssd_fw."
        WARN=1
    fi 
}

function report_gps
{
    POSTIMG=`/EMC/Platform/bin/fw_utility -read -post -verbose| grep Rev | awk ' { print $NF } '`
    if [ "$POSTIMG" == "40.70" ] ; then
        echo "OK:    GPS 20.0.7 loaded for auto-update"
    fi
}

function check_peer
{
    if [ $FULL != 0 ] ; then
        # SSH to peer and run the quick version of this script
        PEERERROR=0
       # sptool -i > /dev/null
       # for AR 705931, remove some codes as below
       # if [ $? == 0 ] ; then
            ping -c 1 -W 5 peer > /dev/null 2>&1
            if [ $? == 0 ] ; then
                echo "====================================================================="
                ssh peer -o ConnectTimeout=5 rm '/var/tmp/*Manifest.txt' &> /dev/null
                scp -o ConnectTimeout=5 $0 /var/tmp/*_Manifest.txt root@peer:/var/tmp 2> /dev/null
                ssh peer -o ConnectTimeout=5 bash /var/tmp/`basename $0` -q
                PEERERROR=$?
                echo "====================================================================="
            else 
                echo "INFO:  Peer not responding - skipping check"
                PEERUNAVAIL=1
            fi 
       # fi 
    fi 
}

function compare_fw_version_on_spa_and_spb
{
    #If full run, compare FW version on SPA/SPB, and throw warning if not same
    if [ $FULL == 1 ] ; then 
        if [ "$PEERUNAVAIL" == 0 -a "$STACK_UP" != 0 ] ; then
            SPABIOS=`grep -A1 BIOS .sptool.r.all | grep -v BIOS | head -1 | awk ' { print $NF }'`
            SPBBIOS=`grep -A1 BIOS .sptool.r.all | grep -v BIOS | tail -1 | awk ' { print $NF }'`
            SPAPOST=`grep -A1 POST .sptool.r.all | grep -v POST | head -1 | awk ' { print $NF }'`
            SPBPOST=`grep -A1 POST .sptool.r.all | grep -v POST | tail -1 | awk ' { print $NF }'`
            SPABMC=`grep -A1 "BMC MAIN" .sptool.r.all | grep -v "BMC MAIN" | head -1 | awk ' { print $NF }'`
            SPBBMC=`grep -A1 "BMC MAIN" .sptool.r.all | grep -v "BMC MAIN" | tail -1 | awk ' { print $NF }'`
            SPASSP=`grep -A1 "BMC SSP" .sptool.r.all | grep -v "BMC SSP" | head -1 | awk ' { print $NF }'`
            SPBSSP=`grep -A1 "BMC SSP" .sptool.r.all | grep -v "BMC SSP" | tail -1 | awk ' { print $NF }'`
            if [ "$SPABIOS" != "$SPBBIOS" ] ; then
                echo "WARN: BIOS on SPA $SPABIOS is not same as on SPB $SPBBIOS"
                WARN=1
            fi
            if [ "$SPAPOST" != "$SPBPOST" ] ; then
                echo "WARN: POST on SPA $SPAPOST is not same as on SPB $SPBPOST"
                WARN=1
            fi

            if [ "$SPABMC" != "$SPBBMC" ] ; then  
                echo "WARN: BMC on SPA $SPABMC is not same as on SPB $SPBBMC"
                WARN=1
            fi

            if [ "$SPASSP" != "$SPBSSP"  ] ; then
                echo "WARN: SSP on SPA $SPASSP is not same as on SPB $SPBSSP"
                WARN=1
            fi
        fi
    fi
}

function report_summary
{
    # If full run, print out the summary messages
    if [ $FULL == 1 ] ; then 
        if [ "$ERROR" == "0" -a "$PEERERROR" == "0" ] ; then
            if [ "$WARN" != "0" ] ; then
                echo "WARN:  Your system firmware looks up to date, but see warnings above."
            else
                echo "OK:    Congratulations!  Your system is up to date!"
            fi
        else
            echo "ERROR: Please update the versions as directed."
        fi
    fi
}



# preparation
build_family_data
build_platform_data
create_cache_files

# reports
report_platform
report_sp
report_version
report_chassis
report_system_type
report_post
report_bmc
report_ssp
report_bios
report_bmc_mac
report_iscsi_$CPLAT
report_board_rev
report_tco_wdog
report_cdes
report_fan_fw_$CPLAT
report_bbu_$CFAM
report_slic
report_cmd_$CPLAT
report_pmc_$CPLAT
report_power_supply_part
report_power_supply_mcu_$CFAM
report_ram_status_$CPLAT
report_ssd
report_gps
report_cpu_$CPLAT
report_Hilda_$CPLAT

# SSH to peer and run the quick version of this script
check_peer

compare_fw_version_on_spa_and_spb

report_summary

cleanup_cache_files

exit $ERROR
#
